var tipuesearch = {"pages":[{"title":" Data structures for Fortran ","text":"Data structures for Fortran Fortran Module: datastructs-fortran Description The Fortran module datastructs-fortran provides a comprehensive collection of common data structures and utility functions. It includes implementations for dynamic lists ( dynamical_list_t ), fixed-size lists ( fixed_list_t ), and max heaps ( maxheap_t ). Additionally, it offers various random sampler algorithms (through sampler_base_t and choose_sampler ) for weighted selection, and a hashing function ( djb2 ). The samplers depend on the rndgen-fortran random number generator. Usage To integrate datastructs-fortran into your project, add it as a dependency using the Fortran Package Manager (Fpm). Include the following lines in your fpm.toml file: [dependencies] datastructs-fortran . git = \"https://github.com/wcota/datastructs-fortran\" After adding the dependency, you can import the module or specific components into your Fortran source files. For example, use use datastructs_fortran to import the entire module, or use datastructs_fortran, only: [component_name] to import specific types or functions. Main modules: Dynamical List ( dynamical_list_t ): Create and manipulate a list that can grow or shrink dynamically. Examples at example/dynamical_list.f90 and example/dynamical_list2.f90 Fixed List ( fixed_list_t ): Define a fixed-size list, which can be linked to others. Examples at example/fixed_list.f90 Max Heap ( maxheap_t ): Implement a max heap structure, where the parent node is always greater than or equal to its children. Examples at example/maxheap.f90 Hash Function ( djb2 ): Calculate a hash value for an array of integers using the djb2 algorithm. Examples at example/hash.f90 Sampler Algorithms ( sampler_base_t , choose_sampler ): Randomly get indexes proportionally to their weights. Examples at example/sampler.f90 Running examples Use fpm run --example name , in which name is the name of the example. Developer Info Wesley Cota Assistant Professor of Physics at Federal University of Viçosa (UFV), Brazil","tags":"home","url":"index.html"},{"title":"fixed_list_t – Data structures for Fortran ","text":"type, public :: fixed_list_t Type for a fixed list, that can be used as a list of lists Components Type Visibility Attributes Name Initial integer(kind=i4), public :: initial_index Metadata integer(kind=i4), public :: final_index Metadata integer(kind=i4), public :: n = 0 integer(kind=i4), public, allocatable :: list (:) type( fixed_list_t ), public, pointer :: next type( fixed_list_t ), public, pointer :: prev Finalization Procedures final :: finalize_fixed_list private  subroutine finalize_fixed_list(this) Finalize the list Arguments Type Intent Optional Attributes Name type( fixed_list_t ), intent(inout) :: this Type-Bound Procedures procedure, public :: init => fixed_list_init private  subroutine fixed_list_init(this, i1, i2) Initialize the fixed list\nInput: i1 - initial index, i2 - final index\n       If i2 is not present, i1 is used as the size (final index) Arguments Type Intent Optional Attributes Name class( fixed_list_t ), intent(inout) :: this integer(kind=i4), intent(in) :: i1 integer(kind=i4), intent(in), optional :: i2 procedure, public :: sum => fixed_list_sum private  function fixed_list_sum(this) result(val) Sum the elements of the fixed list Arguments Type Intent Optional Attributes Name class( fixed_list_t ), intent(in) :: this Return Value integer(kind=i4) procedure, public :: print => fixed_list_print private  subroutine fixed_list_print(this) Print the fixed list Arguments Type Intent Optional Attributes Name class( fixed_list_t ), intent(in) :: this","tags":"","url":"type/fixed_list_t.html"},{"title":"weighted_sampler_t – Data structures for Fortran ","text":"type, public, extends( sampler_base_t ) :: weighted_sampler_t Derived type, extending from the base Inherits type~~weighted_sampler_t~4~~InheritsGraph type~weighted_sampler_t~4 weighted_sampler_t type~sampler_base_t sampler_base_t type~weighted_sampler_t~4->type~sampler_base_t type~weighted_sampler_t~2 weighted_sampler_t type~weighted_sampler_t~4->type~weighted_sampler_t~2 samplers type~weighted_sampler_t~2->type~sampler_base_t type~dynamical_list_t dynamical_list_t type~weighted_sampler_t~2->type~dynamical_list_t indices type~maxheap_t maxheap_t type~weighted_sampler_t~2->type~maxheap_t heap Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 type( weighted_sampler_t ), public :: samplers (2) real(kind=dp), public :: threshold = huge(dp) integer(kind=i4), public, allocatable :: sampler_of_index (:) Finalization Procedures final :: sampler_finalize private  subroutine sampler_finalize(this) Finalize the sampler, deallocate resources Arguments Type Intent Optional Attributes Name type( weighted_sampler_t ), intent(inout) :: this Type-Bound Procedures generic, public :: init => init_n , init_w , init_w2 private  subroutine sampler_init(this, n) Initializes the structure with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n private  subroutine sampler_init_w(this, n, w) Initializes with size n and threshold w\nInput: n - number of weights\n       w - threshold for the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w private  subroutine sampler_init_w2(this, n, w1, w2) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w1 - any real number, not used\n       w2 - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 procedure, public :: init_n => sampler_init private  subroutine sampler_init(this, n) Initializes the structure with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n procedure, public :: init_w => sampler_init_w private  subroutine sampler_init_w(this, n, w) Initializes with size n and threshold w\nInput: n - number of weights\n       w - threshold for the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w procedure, public :: init_w2 => sampler_init_w2 private  subroutine sampler_init_w2(this, n, w1, w2) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w1 - any real number, not used\n       w2 - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 procedure, public :: reset => sampler_reset private  subroutine sampler_reset(this) Resets the sampler: clears the list Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this procedure, public :: set_weight => sampler_set_weight private  subroutine sampler_set_weight(this, index, weight) Sets the weight for a given index\nInput: index - index of the element with a given weight\n       weight - weight of the element Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: weight procedure, public :: set_weight_array => sampler_set_weight_array private  subroutine sampler_set_weight_array(this, weights) Sets the weights from an array (full), using its indexes\nWeights should be larger than zero\nIt assumes it was initialized before, and has the same size\nInput: weights - array with the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this real(kind=dp), intent(in) :: weights (:) procedure, public :: add_weight => sampler_add_weight private  subroutine sampler_add_weight(this, index, delta_weight) Adds a weight to the sampler at a given index\nInput: index - index of the element\n       delta_weight - difference to add to its weight Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: delta_weight procedure, public :: sample => sampler_sample private  function sampler_sample(this, gen) result(index) Samples an index from the sampler\nInput: gen - random number generator (rndgen-fortran module)\nOutput: index - sampled index Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(in) :: this class(rndgen), intent(inout) :: gen Return Value integer(kind=i4) procedure, public :: remove => sampler_remove private  subroutine sampler_remove(this, index) Remove an index from the sampler\nImportant: the index is the original one, not the index used internally by the sampler\nInput: index - index of the element to be removed Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index procedure, public :: sum => sampler_sum private  function sampler_sum(this) result(total_weight) Get the sum of all weights\nOutput: total - sum of all weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(in) :: this Return Value real(kind=dp)","tags":"","url":"type/weighted_sampler_t~4.html"},{"title":"weighted_sampler_t – Data structures for Fortran ","text":"type, public, extends( sampler_base_t ) :: weighted_sampler_t Derived type, extending from the base Inherits type~~weighted_sampler_t~~InheritsGraph type~weighted_sampler_t weighted_sampler_t type~sampler_base_t sampler_base_t type~weighted_sampler_t->type~sampler_base_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~weighted_sampler_t~~InheritedByGraph type~weighted_sampler_t weighted_sampler_t type~weighted_sampler_t~5 weighted_sampler_t type~weighted_sampler_t~5->type~weighted_sampler_t btree Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 real(kind=dp), public, allocatable :: tree (:) Finalization Procedures final :: sampler_finalize private  subroutine sampler_finalize(this) Finalize the sampler, deallocate resources Arguments Type Intent Optional Attributes Name type( weighted_sampler_t ), intent(inout) :: this Type-Bound Procedures generic, public :: init => init_n , init_w , init_w2 private  subroutine sampler_init(this, n) Initializes the structure with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n private  subroutine sampler_init_w(this, n, w) Initializes with size n and threshold w\nInput: n - number of weights\n       w - threshold for the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w private  subroutine sampler_init_w2(this, n, w1, w2) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w1 - any real number, not used\n       w2 - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 procedure, public :: init_n => sampler_init private  subroutine sampler_init(this, n) Initializes the structure with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n procedure, public :: init_w => sampler_init_w private  subroutine sampler_init_w(this, n, w) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w procedure, public :: init_w2 => sampler_init_w2 private  subroutine sampler_init_w2(this, n, w1, w2) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w1 - any real number, not used\n       w2 - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 procedure, public :: reset => sampler_reset private  subroutine sampler_reset(this) Resets the sampler: clears the list Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this procedure, public :: set_weight => sampler_set_weight private  subroutine sampler_set_weight(this, index, weight) Sets the weight for a given index\nInput: index - index of the element with a given weight\n       weight - weight of the element Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: weight procedure, public :: set_weight_array => sampler_set_weight_array private  subroutine sampler_set_weight_array(this, weights) Sets the weights from an array (full), using its indexes\nWeights should be larger than zero\nIt assumes it was initialized before, and has the same size\nInput: weights - array with the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this real(kind=dp), intent(in) :: weights (:) procedure, public :: add_weight => sampler_add_weight private  subroutine sampler_add_weight(this, index, delta_weight) Adds a weight to the sampler at a given index\nInput: index - index of the element\n       delta_weight - difference to add to its weight Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: delta_weight procedure, public :: sample => sampler_sample private  function sampler_sample(this, gen) result(index) Samples an index from the sampler\nInput: gen - random number generator (rndgen-fortran module)\nOutput: index - sampled index Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(in) :: this class(rndgen), intent(inout) :: gen Return Value integer(kind=i4) procedure, public :: remove => sampler_remove private  subroutine sampler_remove(this, index) Remove an index from the sampler\nImportant: the index is the original one, not the index used internally by the sampler\nInput: index - index of the element to be removed Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index procedure, public :: sum => sampler_sum private  function sampler_sum(this) result(total) Get the sum of all weights\nOutput: total - sum of all weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(in) :: this Return Value real(kind=dp)","tags":"","url":"type/weighted_sampler_t.html"},{"title":"weighted_sampler_t – Data structures for Fortran ","text":"type, public, extends( sampler_base_t ) :: weighted_sampler_t Derived type, extending from the base Inherits type~~weighted_sampler_t~2~~InheritsGraph type~weighted_sampler_t~2 weighted_sampler_t type~dynamical_list_t dynamical_list_t type~weighted_sampler_t~2->type~dynamical_list_t indices type~maxheap_t maxheap_t type~weighted_sampler_t~2->type~maxheap_t heap type~sampler_base_t sampler_base_t type~weighted_sampler_t~2->type~sampler_base_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~weighted_sampler_t~2~~InheritedByGraph type~weighted_sampler_t~2 weighted_sampler_t type~weighted_sampler_t~4 weighted_sampler_t type~weighted_sampler_t~4->type~weighted_sampler_t~2 samplers type~weighted_sampler_t~5 weighted_sampler_t type~weighted_sampler_t~5->type~weighted_sampler_t~2 samplers Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 type( dynamical_list_t ), public, allocatable :: indices type( maxheap_t ), public, allocatable :: heap integer(kind=i4), public, allocatable :: position_of (:) real(kind=dp), public :: current_sum = 0.0_dp Finalization Procedures final :: sampler_finalize private  subroutine sampler_finalize(this) Finalize the sampler, deallocate resources Arguments Type Intent Optional Attributes Name type( weighted_sampler_t ), intent(inout) :: this Type-Bound Procedures generic, public :: init => init_n , init_w , init_w2 private  subroutine sampler_init(this, n) Initializes the structure with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n private  subroutine sampler_init_w(this, n, w) Initializes with size n and threshold w\nInput: n - number of weights\n       w - threshold for the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w private  subroutine sampler_init_w2(this, n, w1, w2) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w1 - any real number, not used\n       w2 - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 procedure, public :: init_n => sampler_init private  subroutine sampler_init(this, n) Initializes the structure with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n procedure, public :: init_w => sampler_init_w private  subroutine sampler_init_w(this, n, w) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w procedure, public :: init_w2 => sampler_init_w2 private  subroutine sampler_init_w2(this, n, w1, w2) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w1 - any real number, not used\n       w2 - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 procedure, public :: reset => sampler_reset private  subroutine sampler_reset(this) Resets the sampler: clears the list Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this procedure, public :: set_weight => sampler_set_weight private  subroutine sampler_set_weight(this, index, weight) Sets the weight for a given index\nInput: index - index of the element with a given weight\n       weight - weight of the element Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: weight procedure, public :: set_weight_array => sampler_set_weight_array private  subroutine sampler_set_weight_array(this, weights) Sets the weights from an array (full), using its indexes\nWeights should be larger than zero\nIt assumes it was initialized before, and has the same size\nInput: weights - array with the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this real(kind=dp), intent(in) :: weights (:) procedure, public :: add_weight => sampler_add_weight private  subroutine sampler_add_weight(this, index, delta_weight) Adds a weight to the sampler at a given index\nInput: index - index of the element\n       delta_weight - difference to add to its weight Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: delta_weight procedure, public :: sample => sampler_sample private  function sampler_sample(this, gen) result(index) Samples an index from the sampler\nInput: gen - random number generator (rndgen-fortran module)\nOutput: index - sampled index Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(in) :: this class(rndgen), intent(inout) :: gen Return Value integer(kind=i4) procedure, public :: remove => sampler_remove private  subroutine sampler_remove(this, index) Remove an index from the sampler\nImportant: the index is the original one, not the index used internally by the sampler\nInput: index - index of the element to be removed Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index procedure, public :: sum => sampler_sum private  function sampler_sum(this) result(total_weight) Get the sum of all weights\nOutput: total - sum of all weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(in) :: this Return Value real(kind=dp)","tags":"","url":"type/weighted_sampler_t~2.html"},{"title":"sampler_base_t – Data structures for Fortran ","text":"type, public, abstract :: sampler_base_t Base type for all samplers Inherited by type~~sampler_base_t~~InheritedByGraph type~sampler_base_t sampler_base_t type~weighted_sampler_t weighted_sampler_t type~weighted_sampler_t->type~sampler_base_t type~weighted_sampler_t~2 weighted_sampler_t type~weighted_sampler_t~2->type~sampler_base_t type~weighted_sampler_t~3 weighted_sampler_t type~weighted_sampler_t~3->type~sampler_base_t type~weighted_sampler_t~4 weighted_sampler_t type~weighted_sampler_t~4->type~sampler_base_t type~weighted_sampler_t~4->type~weighted_sampler_t~2 samplers type~weighted_sampler_t~5 weighted_sampler_t type~weighted_sampler_t~5->type~sampler_base_t type~weighted_sampler_t~5->type~weighted_sampler_t btree type~weighted_sampler_t~5->type~weighted_sampler_t~2 samplers type~weighted_sampler_t~6 weighted_sampler_t type~weighted_sampler_t~6->type~sampler_base_t type~weighted_sampler_t~6->type~weighted_sampler_t~3 samplers Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 Type-Bound Procedures procedure(i_init_n), public, deferred :: init_n subroutine i_init_n(this, n) Prototype Arguments Type Intent Optional Attributes Name class( sampler_base_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n procedure(i_init_w), public, deferred :: init_w subroutine i_init_w(this, n, w) Prototype Arguments Type Intent Optional Attributes Name class( sampler_base_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w procedure(i_init_w2), public, deferred :: init_w2 subroutine i_init_w2(this, n, w1, w2) Prototype Arguments Type Intent Optional Attributes Name class( sampler_base_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 generic, public :: init => init_n , init_w , init_w2 private  subroutine sampler_init(this, n) Initializes the structure with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n private  subroutine sampler_init_w(this, n, w) Initializes with size n and threshold w\nInput: n - number of weights\n       w - threshold for the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w private  subroutine sampler_init_w2(this, n, w1, w2) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w1 - any real number, not used\n       w2 - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 procedure(i_reset), public, deferred :: reset subroutine i_reset(this) Prototype Arguments Type Intent Optional Attributes Name class( sampler_base_t ), intent(inout) :: this procedure(i_set_weight), public, deferred :: set_weight subroutine i_set_weight(this, index, weight) Prototype Arguments Type Intent Optional Attributes Name class( sampler_base_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: weight procedure(i_set_weight_array), public, deferred :: set_weight_array subroutine i_set_weight_array(this, weights) Prototype Arguments Type Intent Optional Attributes Name class( sampler_base_t ), intent(inout) :: this real(kind=dp), intent(in) :: weights (:) procedure(i_add_weight), public, deferred :: add_weight subroutine i_add_weight(this, index, delta_weight) Prototype Arguments Type Intent Optional Attributes Name class( sampler_base_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: delta_weight procedure(i_sample), public, deferred :: sample function i_sample(this, gen) result(index) Prototype Arguments Type Intent Optional Attributes Name class( sampler_base_t ), intent(in) :: this class(rndgen), intent(inout) :: gen Return Value integer(kind=i4) procedure(i_remove), public, deferred :: remove subroutine i_remove(this, index) Prototype Arguments Type Intent Optional Attributes Name class( sampler_base_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index procedure(i_sum), public, deferred :: sum function i_sum(this) result(total_weight) Prototype Arguments Type Intent Optional Attributes Name class( sampler_base_t ), intent(in) :: this Return Value real(kind=dp)","tags":"","url":"type/sampler_base_t.html"},{"title":"maxheap_t – Data structures for Fortran ","text":"type, public :: maxheap_t Type for a maxheap Inherited by type~~maxheap_t~~InheritedByGraph type~maxheap_t maxheap_t type~weighted_sampler_t~2 weighted_sampler_t type~weighted_sampler_t~2->type~maxheap_t heap type~weighted_sampler_t~4 weighted_sampler_t type~weighted_sampler_t~4->type~weighted_sampler_t~2 samplers type~weighted_sampler_t~5 weighted_sampler_t type~weighted_sampler_t~5->type~weighted_sampler_t~2 samplers Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: values (:) integer(kind=i4), public, allocatable :: indices (:) integer(kind=i4), public, allocatable :: pos_of (:) integer(kind=i4), public :: n = 0 integer(kind=i4), public :: max_n Finalization Procedures final :: maxheap_finalize private  subroutine maxheap_finalize(this) Finalizes the maxheap Arguments Type Intent Optional Attributes Name type( maxheap_t ), intent(inout) :: this Type-Bound Procedures procedure, public :: init => maxheap_init private  subroutine maxheap_init(this, max_size) Initialize an empty maxheap\nInput: max_size - maximum number of elements in the heap Arguments Type Intent Optional Attributes Name class( maxheap_t ), intent(inout) :: this integer(kind=i4), intent(in) :: max_size procedure, public :: add => maxheap_add private  subroutine maxheap_add(this, value, index) Adds a new value to the maxheap, with a corresponding index\nInput: value - the value to add\n       index - the corresponding index of the value Arguments Type Intent Optional Attributes Name class( maxheap_t ), intent(inout) :: this real(kind=dp), intent(in) :: value integer(kind=i4), intent(in) :: index procedure, public :: remove => maxheap_remove private  subroutine maxheap_remove(this, index) Removes a value from the maxheap\nInput: index - the corresponding index of the value Arguments Type Intent Optional Attributes Name class( maxheap_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index procedure, public :: add_weight => maxheap_add_weight private  subroutine maxheap_add_weight(this, delta_weight, index) Adds a delta weight to an existing index\nInput: delta_weight - the weight to add\n       index - the corresponding index of the value Arguments Type Intent Optional Attributes Name class( maxheap_t ), intent(inout) :: this real(kind=dp), intent(in) :: delta_weight integer(kind=i4), intent(in) :: index procedure, public :: print => maxheap_print private  subroutine maxheap_print(this) Prints the contents of the maxheap Arguments Type Intent Optional Attributes Name class( maxheap_t ), intent(in) :: this procedure, public :: max_value => maxheap_max_value private  function maxheap_max_value(this) result(value) Gets the maximum value from the maxheap Arguments Type Intent Optional Attributes Name class( maxheap_t ), intent(in) :: this Return Value real(kind=dp) procedure, public :: max_index => maxheap_max_index private  function maxheap_max_index(this) result(index) Gets the original index of the maximum value Arguments Type Intent Optional Attributes Name class( maxheap_t ), intent(in) :: this Return Value integer(kind=i4)","tags":"","url":"type/maxheap_t.html"},{"title":"dynamical_list_t – Data structures for Fortran ","text":"type, public :: dynamical_list_t List of integers with a given maximum fixed size\nThe first index is always 1, and filled up to n_used\nIt contains routines for managing the list Inherited by type~~dynamical_list_t~~InheritedByGraph type~dynamical_list_t dynamical_list_t type~weighted_sampler_t~2 weighted_sampler_t type~weighted_sampler_t~2->type~dynamical_list_t indices type~weighted_sampler_t~3 weighted_sampler_t type~weighted_sampler_t~3->type~dynamical_list_t indices type~weighted_sampler_t~4 weighted_sampler_t type~weighted_sampler_t~4->type~weighted_sampler_t~2 samplers type~weighted_sampler_t~5 weighted_sampler_t type~weighted_sampler_t~5->type~weighted_sampler_t~2 samplers type~weighted_sampler_t~6 weighted_sampler_t type~weighted_sampler_t~6->type~weighted_sampler_t~3 samplers Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=i4), public :: n = 0 integer(kind=i4), public :: n_used = 0 integer(kind=i4), public, allocatable :: list (:) Finalization Procedures final :: finalize_dynamical_list private  subroutine finalize_dynamical_list(this) Finalize the list\nFor that, we need to deallocate the list Arguments Type Intent Optional Attributes Name type( dynamical_list_t ), intent(inout) :: this Type-Bound Procedures procedure, public :: init => dynamical_list_init private  subroutine dynamical_list_init(this, n) Initialize an empty list with a given size\nInput: n - the size of the list Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n procedure, public :: reset => dynamical_list_reset private  subroutine dynamical_list_reset(this) Reset the list\nFor that, we only need to set n_used to 0 Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(inout) :: this procedure, public :: print => dynamical_list_print private  subroutine dynamical_list_print(this) Print the list Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(in) :: this procedure, public :: expand => dynamical_list_expand private  subroutine dynamical_list_expand(this, new_size) Expand the list to a new size Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(inout) :: this integer(kind=i4), intent(in) :: new_size procedure, public :: trim => dynamical_list_trim private  subroutine dynamical_list_trim(this) Trim the list to the number of used elements Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(inout) :: this procedure, public :: last => dynamical_list_last private  function dynamical_list_last(this) result(val) Returns the last element of the list Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(in) :: this Return Value integer(kind=i4) procedure, public :: count => dynamical_list_count private  function dynamical_list_count(this, element) result(cnt) Count the number of times an element appears in the list Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(in) :: this integer(kind=i4), intent(in) :: element Return Value integer(kind=i4) generic, public :: add => dynamical_list_add_element, dynamical_list_add_array private  subroutine dynamical_list_add_element(this, element) Add an element to the list\nIt assumes that the list is already allocated\nThe element is added to the end of the list\nInput: element - the element to add Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(inout) :: this integer(kind=i4), intent(in) :: element private  subroutine dynamical_list_add_array(this, array) Add an array to the list\nIt will initialize the list if it is not already allocated, with the size of the array\nInput: array - the array to add Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(inout) :: this integer(kind=i4), intent(in) :: array (:) generic, public :: remove => dynamical_list_remove_position, dynamical_list_remove_position_array, dynamical_list_remove_position_range private  subroutine dynamical_list_remove_position(this, position) Remove an element from the list\nIt will replace the element at the given position with the last element\nWARNING: This can change the position of the elements in the list, DO NOT use sequentially\n with the original indexes, that are not updated after each removal\nInput: position - the position of the element to remove Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(inout) :: this integer(kind=i4), intent(in) :: position private  subroutine dynamical_list_remove_position_array(this, position_arr) Remove a list of elements from the list\nIt will replace the elements in the list with the last elements\nFor that, we need to sort the positions\nIt is safe because the elements are removed in reverse order\nInput: position_arr - the array of positions to remove\nDependency: stdlib_sorting Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(inout) :: this integer(kind=i4), intent(in) :: position_arr (:) private  subroutine dynamical_list_remove_position_range(this, ini_position, fin_position) Remove a range of elements from the list\nIt will replace the elements in the range with the last elements\nThis is safe because the elements are removed in reverse order\nInput: ini_position - the initial position of the range to remove\n       fin_position - the final position of the range to remove Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(inout) :: this integer(kind=i4), intent(in) :: ini_position integer(kind=i4), intent(in) :: fin_position generic, public :: assignment(=) => dynamical_list_create_from_array private  subroutine dynamical_list_create_from_array(this, array) Create from array, if it is not already allocated\nInput: array - the array to create the list from Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(inout) :: this integer(kind=i4), intent(in) :: array (:) procedure, public :: get => dynamical_list_get private  function dynamical_list_get(this, position) result(val) Returns the element at the given position\nInput: position - the position of the element to return Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(in) :: this integer(kind=i4), intent(in) :: position Return Value integer(kind=i4) procedure, public :: sum => dynamical_list_sum private  function dynamical_list_sum(this) result(val) Return the sum of the elements in the list\nIt sums only the valid elements Arguments Type Intent Optional Attributes Name class( dynamical_list_t ), intent(in) :: this Return Value integer(kind=i4)","tags":"","url":"type/dynamical_list_t.html"},{"title":"weighted_sampler_t – Data structures for Fortran ","text":"type, public, extends( sampler_base_t ) :: weighted_sampler_t Derived type, extending from the base Inherits type~~weighted_sampler_t~5~~InheritsGraph type~weighted_sampler_t~5 weighted_sampler_t type~sampler_base_t sampler_base_t type~weighted_sampler_t~5->type~sampler_base_t type~weighted_sampler_t weighted_sampler_t type~weighted_sampler_t~5->type~weighted_sampler_t btree type~weighted_sampler_t~2 weighted_sampler_t type~weighted_sampler_t~5->type~weighted_sampler_t~2 samplers type~weighted_sampler_t->type~sampler_base_t type~weighted_sampler_t~2->type~sampler_base_t type~dynamical_list_t dynamical_list_t type~weighted_sampler_t~2->type~dynamical_list_t indices type~maxheap_t maxheap_t type~weighted_sampler_t~2->type~maxheap_t heap Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 type( weighted_sampler_t ), public, allocatable :: samplers (:) integer(kind=i4), public :: q = 0 type( weighted_sampler_t ), public :: btree integer(kind=i4), public, allocatable :: sampler_of_index (:) real(kind=dp), public :: wmin real(kind=dp), public :: wmax Finalization Procedures final :: sampler_finalize private  subroutine sampler_finalize(this) Finalize the sampler, deallocate resources Arguments Type Intent Optional Attributes Name type( weighted_sampler_t ), intent(inout) :: this Type-Bound Procedures generic, public :: init => init_n , init_w , init_w2 private  subroutine sampler_init(this, n) Initializes the structure with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n private  subroutine sampler_init_w(this, n, w) Initializes with size n and threshold w\nInput: n - number of weights\n       w - threshold for the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w private  subroutine sampler_init_w2(this, n, w1, w2) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w1 - any real number, not used\n       w2 - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 procedure, public :: init_n => sampler_init private  subroutine sampler_init(this, n) Initializes the structure with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n procedure, public :: init_w => sampler_init_w private  subroutine sampler_init_w(this, n, w) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w procedure, public :: init_w2 => sampler_init_w2 private  subroutine sampler_init_w2(this, n, w1, w2) Initializes the sampler giving its minimum and maximum weights\nThis calculates the number of rejection samplers to use\nInput: n - number of weights\n       w1 - minimum weight\n       w2 - maximum weight Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 procedure, public :: reset => sampler_reset private  subroutine sampler_reset(this) Resets the sampler: clears the list Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this procedure, public :: set_weight => sampler_set_weight private  subroutine sampler_set_weight(this, index, weight) Sets the weight for a given index\nInput: index - index of the element with a given weight\n       weight - weight of the element Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: weight procedure, public :: set_weight_array => sampler_set_weight_array private  subroutine sampler_set_weight_array(this, weights) Sets the weights from an array (full), using its indexes\nWeights should be larger than zero\nIt assumes it was initialized before, and has the same size\nInput: weights - array with the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this real(kind=dp), intent(in) :: weights (:) procedure, public :: add_weight => sampler_add_weight private  subroutine sampler_add_weight(this, index, delta_weight) Adds a weight to the sampler at a given index\nInput: index - index of the element\n       delta_weight - difference to add to its weight Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: delta_weight procedure, public :: sample => sampler_sample private  function sampler_sample(this, gen) result(index) Samples an index from the sampler\nInput: gen - random number generator (rndgen-fortran module)\nOutput: index - sampled index Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(in) :: this class(rndgen), intent(inout) :: gen Return Value integer(kind=i4) procedure, public :: remove => sampler_remove private  subroutine sampler_remove(this, index) Remove an index from the sampler\nImportant: the index is the original one, not the index used internally by the sampler\nInput: index - index of the element to be removed Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index procedure, public :: sum => sampler_sum private  function sampler_sum(this) result(total_weight) Get the sum of all weights\nOutput: total - sum of all weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(in) :: this Return Value real(kind=dp) procedure, public :: sampler_pos => sampler_sampler_pos private  function sampler_sampler_pos(this, weight) result(pos) Auxiliary function (private) to get the sampler position for a given weight\nInput: weight - the weight to find the sampler position for Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(in) :: this real(kind=dp), intent(in) :: weight Return Value integer(kind=i4)","tags":"","url":"type/weighted_sampler_t~5.html"},{"title":"weighted_sampler_t – Data structures for Fortran ","text":"type, public, extends( sampler_base_t ) :: weighted_sampler_t Derived type, extending from the base Inherits type~~weighted_sampler_t~6~~InheritsGraph type~weighted_sampler_t~6 weighted_sampler_t type~sampler_base_t sampler_base_t type~weighted_sampler_t~6->type~sampler_base_t type~weighted_sampler_t~3 weighted_sampler_t type~weighted_sampler_t~6->type~weighted_sampler_t~3 samplers type~weighted_sampler_t~3->type~sampler_base_t type~dynamical_list_t dynamical_list_t type~weighted_sampler_t~3->type~dynamical_list_t indices Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 type( weighted_sampler_t ), public :: samplers (2) real(kind=dp), public :: threshold = huge(dp) integer(kind=i4), public, allocatable :: sampler_of_index (:) Finalization Procedures final :: sampler_finalize private  subroutine sampler_finalize(this) Finalize the sampler, deallocate resources Arguments Type Intent Optional Attributes Name type( weighted_sampler_t ), intent(inout) :: this Type-Bound Procedures generic, public :: init => init_n , init_w , init_w2 private  subroutine sampler_init(this, n) Initializes the structure with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n private  subroutine sampler_init_w(this, n, w) Initializes with size n and threshold w\nInput: n - number of weights\n       w - threshold for the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w private  subroutine sampler_init_w2(this, n, w1, w2) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w1 - any real number, not used\n       w2 - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 procedure, public :: init_n => sampler_init private  subroutine sampler_init(this, n) Initializes the structure with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n procedure, public :: init_w => sampler_init_w private  subroutine sampler_init_w(this, n, w) Initializes with size n and threshold w\nInput: n - number of weights\n       w - threshold for the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w procedure, public :: init_w2 => sampler_init_w2 private  subroutine sampler_init_w2(this, n, w1, w2) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w1 - any real number, not used\n       w2 - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 procedure, public :: reset => sampler_reset private  subroutine sampler_reset(this) Resets the sampler: clears the list Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this procedure, public :: set_weight => sampler_set_weight private  subroutine sampler_set_weight(this, index, weight) Sets the weight for a given index\nInput: index - index of the element with a given weight\n       weight - weight of the element Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: weight procedure, public :: set_weight_array => sampler_set_weight_array private  subroutine sampler_set_weight_array(this, weights) Sets the weights from an array (full), using its indexes\nWeights should be larger than zero\nIt assumes it was initialized before, and has the same size\nInput: weights - array with the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this real(kind=dp), intent(in) :: weights (:) procedure, public :: add_weight => sampler_add_weight private  subroutine sampler_add_weight(this, index, delta_weight) Adds a weight to the sampler at a given index\nInput: index - index of the element\n       delta_weight - difference to add to its weight Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: delta_weight procedure, public :: sample => sampler_sample private  function sampler_sample(this, gen) result(index) Samples an index from the sampler\nInput: gen - random number generator (rndgen-fortran module)\nOutput: index - sampled index Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(in) :: this class(rndgen), intent(inout) :: gen Return Value integer(kind=i4) procedure, public :: remove => sampler_remove private  subroutine sampler_remove(this, index) Remove an index from the sampler\nImportant: the index is the original one, not the index used internally by the sampler\nInput: index - index of the element to be removed Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index procedure, public :: sum => sampler_sum private  function sampler_sum(this) result(total_weight) Get the sum of all weights\nOutput: total - sum of all weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(in) :: this Return Value real(kind=dp)","tags":"","url":"type/weighted_sampler_t~6.html"},{"title":"weighted_sampler_t – Data structures for Fortran ","text":"type, public, extends( sampler_base_t ) :: weighted_sampler_t Derived type, extending from the base Inherits type~~weighted_sampler_t~3~~InheritsGraph type~weighted_sampler_t~3 weighted_sampler_t type~dynamical_list_t dynamical_list_t type~weighted_sampler_t~3->type~dynamical_list_t indices type~sampler_base_t sampler_base_t type~weighted_sampler_t~3->type~sampler_base_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~weighted_sampler_t~3~~InheritedByGraph type~weighted_sampler_t~3 weighted_sampler_t type~weighted_sampler_t~6 weighted_sampler_t type~weighted_sampler_t~6->type~weighted_sampler_t~3 samplers Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 type( dynamical_list_t ), public, allocatable :: indices integer(kind=i4), public, allocatable :: position_of (:) real(kind=dp), public :: current_sum = 0.0_dp real(kind=dp), public :: max_weight = 0.0_dp Finalization Procedures final :: sampler_finalize private  subroutine sampler_finalize(this) Finalize the sampler, deallocate resources Arguments Type Intent Optional Attributes Name type( weighted_sampler_t ), intent(inout) :: this Type-Bound Procedures generic, public :: init => init_n , init_w , init_w2 private  subroutine sampler_init(this, n) Initializes the structure with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n private  subroutine sampler_init_w(this, n, w) Initializes with size n and threshold w\nInput: n - number of weights\n       w - threshold for the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w private  subroutine sampler_init_w2(this, n, w1, w2) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w1 - any real number, not used\n       w2 - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 procedure, public :: init_n => sampler_init private  subroutine sampler_init(this, n) Initializes the structure with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n procedure, public :: init_w => sampler_init_w private  subroutine sampler_init_w(this, n, w) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w procedure, public :: init_w2 => sampler_init_w2 private  subroutine sampler_init_w2(this, n, w1, w2) Placeholder for 1D initialization (compat mode), maps to original init\nInput: n - number of weights\n       w1 - any real number, not used\n       w2 - any real number, not used Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: n real(kind=dp), intent(in) :: w1 real(kind=dp), intent(in) :: w2 procedure, public :: reset => sampler_reset private  subroutine sampler_reset(this) Resets the sampler: clears the list Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this procedure, public :: set_weight => sampler_set_weight private  subroutine sampler_set_weight(this, index, weight) Sets the weight for a given index\nInput: index - index of the element with a given weight\n       weight - weight of the element Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: weight procedure, public :: set_weight_array => sampler_set_weight_array private  subroutine sampler_set_weight_array(this, weights) Sets the weights from an array (full), using its indexes\nWeights should be larger than zero\nIt assumes it was initialized before, and has the same size\nInput: weights - array with the weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this real(kind=dp), intent(in) :: weights (:) procedure, public :: add_weight => sampler_add_weight private  subroutine sampler_add_weight(this, index, delta_weight) Adds a weight to the sampler at a given index\nInput: index - index of the element\n       delta_weight - difference to add to its weight Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index real(kind=dp), intent(in) :: delta_weight procedure, public :: sample => sampler_sample private  function sampler_sample(this, gen) result(index) Samples an index from the sampler\nInput: gen - random number generator (rndgen-fortran module)\nOutput: index - sampled index Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(in) :: this class(rndgen), intent(inout) :: gen Return Value integer(kind=i4) procedure, public :: remove => sampler_remove private  subroutine sampler_remove(this, index) Remove an index from the sampler\nImportant: the index is the original one, not the index used internally by the sampler\nInput: index - index of the element to be removed Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(inout) :: this integer(kind=i4), intent(in) :: index procedure, public :: sum => sampler_sum private  function sampler_sum(this) result(total_weight) Get the sum of all weights\nOutput: total - sum of all weights Arguments Type Intent Optional Attributes Name class( weighted_sampler_t ), intent(in) :: this Return Value real(kind=dp)","tags":"","url":"type/weighted_sampler_t~3.html"},{"title":"choose_sampler – Data structures for Fortran","text":"public  subroutine choose_sampler(weighted_sampler, selected_algorithm) Uses samplers_rejection_maxheap_two_classes_mod samplers_rejection_maxheap_mod samplers_rejection_maxheap_composition_mod samplers_rejection_mod samplers_btree_mod samplers_rejection_two_classes_mod proc~~choose_sampler~~UsesGraph proc~choose_sampler choose_sampler module~samplers_btree_mod samplers_btree_mod proc~choose_sampler->module~samplers_btree_mod module~samplers_rejection_maxheap_composition_mod samplers_rejection_maxheap_composition_mod proc~choose_sampler->module~samplers_rejection_maxheap_composition_mod module~samplers_rejection_maxheap_mod samplers_rejection_maxheap_mod proc~choose_sampler->module~samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_two_classes_mod samplers_rejection_maxheap_two_classes_mod proc~choose_sampler->module~samplers_rejection_maxheap_two_classes_mod module~samplers_rejection_mod samplers_rejection_mod proc~choose_sampler->module~samplers_rejection_mod module~samplers_rejection_two_classes_mod samplers_rejection_two_classes_mod proc~choose_sampler->module~samplers_rejection_two_classes_mod module~kinds_mod kinds_mod module~samplers_btree_mod->module~kinds_mod module~samplers_base_mod samplers_base_mod module~samplers_btree_mod->module~samplers_base_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_btree_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_composition_mod->module~kinds_mod module~lists_mod lists_mod module~samplers_rejection_maxheap_composition_mod->module~lists_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_base_mod module~samplers_rejection_maxheap_mod->module~kinds_mod module~samplers_rejection_maxheap_mod->module~lists_mod module~samplers_rejection_maxheap_mod->module~samplers_base_mod module~samplers_rejection_maxheap_two_classes_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_two_classes_mod->module~kinds_mod module~samplers_rejection_maxheap_two_classes_mod->module~lists_mod module~samplers_rejection_maxheap_two_classes_mod->module~samplers_base_mod module~samplers_rejection_mod->module~kinds_mod module~samplers_rejection_mod->module~lists_mod module~samplers_rejection_mod->module~samplers_base_mod module~samplers_rejection_two_classes_mod->module~samplers_rejection_mod module~samplers_rejection_two_classes_mod->module~kinds_mod module~samplers_rejection_two_classes_mod->module~lists_mod module~samplers_rejection_two_classes_mod->module~samplers_base_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env module~lists_mod->module~kinds_mod module~lists_dynamical_list_mod lists_dynamical_list_mod module~lists_mod->module~lists_dynamical_list_mod module~lists_fixed_list_mod lists_fixed_list_mod module~lists_mod->module~lists_fixed_list_mod module~maxheap_mod maxheap_mod module~lists_mod->module~maxheap_mod module~samplers_base_mod->module~kinds_mod module~lists_dynamical_list_mod->module~kinds_mod module~lists_fixed_list_mod->module~kinds_mod module~maxheap_mod->module~kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutine to allocate a class(sampler_base_t) to its respective object Arguments Type Intent Optional Attributes Name class( sampler_base_t ), intent(out), allocatable :: weighted_sampler character(len=*), intent(in) :: selected_algorithm","tags":"","url":"proc/choose_sampler.html"},{"title":"unique_values – Data structures for Fortran","text":"public  function unique_values(list) result(unique) Uses stdlib_sorting proc~~unique_values~~UsesGraph proc~unique_values unique_values stdlib_sorting stdlib_sorting proc~unique_values->stdlib_sorting Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Find unique values in a list of integers\nIt uses the standard library sorting module\nThe result is a list of unique integers Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: list (:) Return Value integer(kind=i4), allocatable, (:) Calls proc~~unique_values~~CallsGraph proc~unique_values unique_values sort sort proc~unique_values->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/unique_values.html"},{"title":"new_fixed_list_pointer – Data structures for Fortran","text":"public  function new_fixed_list_pointer(list) result(this) Create a new fixed list pointer\nInput: list - an array of integers Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: list (:) Return Value type( fixed_list_t ), pointer","tags":"","url":"proc/new_fixed_list_pointer.html"},{"title":"fixed_list – Data structures for Fortran","text":"public interface fixed_list Constructor for a fixed list Module Procedures private  function fixed_list_new(list) result(this) Create a new fixed list\nInput: list - an array of integers Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: list (:) Return Value type( fixed_list_t )","tags":"","url":"interface/fixed_list.html"},{"title":"weighted_sampler – Data structures for Fortran","text":"public interface weighted_sampler Constructor Module Procedures private  function weighted_sampler_new(n) result(this) Create a new rejection sampler with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n Return Value type( weighted_sampler_t )","tags":"","url":"interface/weighted_sampler.html"},{"title":"weighted_sampler – Data structures for Fortran","text":"public interface weighted_sampler Constructor Module Procedures private  function weighted_sampler_new(n) result(this) Create a new binary tree sampler with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n Return Value type( weighted_sampler_t )","tags":"","url":"interface/weighted_sampler~2.html"},{"title":"weighted_sampler – Data structures for Fortran","text":"public interface weighted_sampler Constructor Module Procedures private  function weighted_sampler_new(n) result(this) Create a new rejection sampler with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n Return Value type( weighted_sampler_t )","tags":"","url":"interface/weighted_sampler~3.html"},{"title":"choose_fmt_based_on – Data structures for Fortran","text":"public  function choose_fmt_based_on(filename) result(fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value character(len=:), allocatable","tags":"","url":"proc/choose_fmt_based_on.html"},{"title":"count_integers_from_string – Data structures for Fortran","text":"public  function count_integers_from_string(str) result(count) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer(kind=i4)","tags":"","url":"proc/count_integers_from_string.html"},{"title":"list_ranges – Data structures for Fortran","text":"public  subroutine list_ranges() Arguments None","tags":"","url":"proc/list_ranges.html"},{"title":"swap – Data structures for Fortran","text":"public interface swap Interface for the swap subroutine. Module Procedures private  subroutine swap_int(a, b) Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(inout) :: a integer(kind=i4), intent(inout) :: b private  subroutine swap_real(a, b) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: a real(kind=dp), intent(inout) :: b","tags":"","url":"interface/swap.html"},{"title":"djb2 – Data structures for Fortran","text":"public  function djb2(list) result(r) DJB2 hash function\nInspired by http://www.cse.yorku.ca/~oz/hash.html\nand https://github.com/pdebuyl/fortran_hash_table/blob/master/src/dictionary_m.f90 Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: list (:) Return Value integer(kind=i8)","tags":"","url":"proc/djb2.html"},{"title":"maxheap – Data structures for Fortran","text":"public interface maxheap Constructor for a maxheap Module Procedures private  function maxheap_new(max_size) result(this) Create a new maxheap\nInput: max_size - maximum number of elements in the heap Arguments Type Intent Optional Attributes Name integer(kind=i4) :: max_size Return Value type( maxheap_t )","tags":"","url":"interface/maxheap.html"},{"title":"dynamical_list – Data structures for Fortran","text":"public interface dynamical_list Constructor for a dynamical list Module Procedures private  function dynamical_list_new(list) result(this) Create a new dynamical list\nInput: list - an array of integers\nOutput: a new dynamical list Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: list (:) Return Value type( dynamical_list_t )","tags":"","url":"interface/dynamical_list.html"},{"title":"weighted_sampler – Data structures for Fortran","text":"public interface weighted_sampler Constructor Module Procedures private  function weighted_sampler_new(n) result(this) Create a new sampler with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n Return Value type( weighted_sampler_t )","tags":"","url":"interface/weighted_sampler~4.html"},{"title":"weighted_sampler – Data structures for Fortran","text":"public interface weighted_sampler Constructor Module Procedures private  function weighted_sampler_new(n) result(this) Create a new rejection sampler with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n Return Value type( weighted_sampler_t )","tags":"","url":"interface/weighted_sampler~5.html"},{"title":"weighted_sampler – Data structures for Fortran","text":"public interface weighted_sampler Constructor Module Procedures private  function weighted_sampler_new(n) result(this) Create a new rejection sampler with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n Return Value type( weighted_sampler_t )","tags":"","url":"interface/weighted_sampler~6.html"},{"title":"samplers_mod – Data structures for Fortran","text":"Module to select an weighted sampler\nThe idea is that it contains the list of indexes up to a size n,\nand each index has an weight\nThe sampling is done proportionally to the weights.\nIt depends on the rndgen-fortran module, found at https://github.com/wcota/rndgen-fortran Each sampler algorithm is implemented separately.\n!> Example: program example_sampler use datastructs_fortran use kinds_mod use rndgen_mod implicit none type ( rndgen ) :: gen class ( sampler_base_t ), allocatable :: my_sampler integer ( kind = i4 ) :: i real ( kind = dp ), parameter :: weights ( * ) = [ 10 0.0_dp , 5 0.0_dp , 20 0.0_dp , 2 5.0_dp ] integer ( kind = i4 ), allocatable :: count_times (:) integer ( kind = i4 ) :: selected_index integer ( kind = i4 ), parameter :: n_samples = 10000 ! choose the sampler algorithm call choose_sampler ( my_sampler , 'btree' ) call my_sampler % init ( size ( weights )) call my_sampler % set_weight_array ( weights ) ! initialize the random generator with a seed call gen % init ( 12345 ) ! count the number of times each element was selected allocate ( count_times ( size ( weights ))) count_times = 0 ! Sample from the distribution do i = 1 , n_samples selected_index = my_sampler % sample ( gen ) !write(*, fmt_general) \"Selected index:\", selected_index count_times ( selected_index ) = count_times ( selected_index ) + 1 end do ! Print the result write ( * , fmt_general ) \"For n_samples = \" , n_samples do i = 1 , size ( weights ) write ( * , fmt_general ) \"@ Index:\" , i , \" Weight:\" , weights ( i ), \"Count:\" , count_times ( i ), \"Prob:\" , 1.0_dp * count_times ( i ) / sum ( count_times ), \"Expected prob:\" , weights ( i ) / sum ( weights ) end do end program example_sampler Uses samplers_base_mod kinds_mod module~~samplers_mod~~UsesGraph module~samplers_mod samplers_mod module~kinds_mod kinds_mod module~samplers_mod->module~kinds_mod module~samplers_base_mod samplers_base_mod module~samplers_mod->module~samplers_base_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env module~samplers_base_mod->module~kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~samplers_mod~~UsedByGraph module~samplers_mod samplers_mod module~datastructs_fortran datastructs_fortran module~datastructs_fortran->module~samplers_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: samplers_choices = 'btree,rejection,rejection_two_classes,rejection_maxheap,rejection_maxheap_two_classes,rejection_maxheap_composition' List of available sampler algorithms Subroutines public  subroutine choose_sampler (weighted_sampler, selected_algorithm) Subroutine to allocate a class(sampler_base_t) to its respective object Arguments Type Intent Optional Attributes Name class( sampler_base_t ), intent(out), allocatable :: weighted_sampler character(len=*), intent(in) :: selected_algorithm","tags":"","url":"module/samplers_mod.html"},{"title":"lists_mod – Data structures for Fortran","text":"General module for lists and related operations\nConstructors Derived types Operations Uses lists_dynamical_list_mod maxheap_mod lists_fixed_list_mod kinds_mod module~~lists_mod~~UsesGraph module~lists_mod lists_mod module~kinds_mod kinds_mod module~lists_mod->module~kinds_mod module~lists_dynamical_list_mod lists_dynamical_list_mod module~lists_mod->module~lists_dynamical_list_mod module~lists_fixed_list_mod lists_fixed_list_mod module~lists_mod->module~lists_fixed_list_mod module~maxheap_mod maxheap_mod module~lists_mod->module~maxheap_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env module~lists_dynamical_list_mod->module~kinds_mod module~lists_fixed_list_mod->module~kinds_mod module~maxheap_mod->module~kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lists_mod~~UsedByGraph module~lists_mod lists_mod module~datastructs_fortran datastructs_fortran module~datastructs_fortran->module~lists_mod module~samplers_rejection_maxheap_composition_mod samplers_rejection_maxheap_composition_mod module~samplers_rejection_maxheap_composition_mod->module~lists_mod module~samplers_rejection_maxheap_mod samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_mod->module~lists_mod module~samplers_rejection_maxheap_two_classes_mod samplers_rejection_maxheap_two_classes_mod module~samplers_rejection_maxheap_two_classes_mod->module~lists_mod module~samplers_rejection_maxheap_two_classes_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_mod samplers_rejection_mod module~samplers_rejection_mod->module~lists_mod module~samplers_rejection_two_classes_mod samplers_rejection_two_classes_mod module~samplers_rejection_two_classes_mod->module~lists_mod module~samplers_rejection_two_classes_mod->module~samplers_rejection_mod proc~choose_sampler choose_sampler proc~choose_sampler->module~samplers_rejection_maxheap_composition_mod proc~choose_sampler->module~samplers_rejection_maxheap_mod proc~choose_sampler->module~samplers_rejection_maxheap_two_classes_mod proc~choose_sampler->module~samplers_rejection_mod proc~choose_sampler->module~samplers_rejection_two_classes_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function unique_values (list) result(unique) Find unique values in a list of integers\nIt uses the standard library sorting module\nThe result is a list of unique integers Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: list (:) Return Value integer(kind=i4), allocatable, (:)","tags":"","url":"module/lists_mod.html"},{"title":"lists_fixed_list_mod – Data structures for Fortran","text":"This module implements a fixed list, that has a fixed size and cannot be resized.\nIt also has pointers, allowing to build a linked list structure.\nExample: program example_fixed_list use datastructs_fortran use kinds_mod implicit none type ( fixed_list_t ) :: my_list type ( fixed_list_t ), target :: my_list2 my_list = fixed_list ([ 1 , 2 , 3 , 4 , 5 ]) my_list2 = fixed_list ([ 6 , 7 , 8 ]) call my_list % print () my_list % next => my_list2 call my_list % next % print () end program example_fixed_list Uses kinds_mod module~~lists_fixed_list_mod~~UsesGraph module~lists_fixed_list_mod lists_fixed_list_mod module~kinds_mod kinds_mod module~lists_fixed_list_mod->module~kinds_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lists_fixed_list_mod~~UsedByGraph module~lists_fixed_list_mod lists_fixed_list_mod module~lists_mod lists_mod module~lists_mod->module~lists_fixed_list_mod module~datastructs_fortran datastructs_fortran module~datastructs_fortran->module~lists_mod module~samplers_rejection_maxheap_composition_mod samplers_rejection_maxheap_composition_mod module~samplers_rejection_maxheap_composition_mod->module~lists_mod module~samplers_rejection_maxheap_mod samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_mod->module~lists_mod module~samplers_rejection_maxheap_two_classes_mod samplers_rejection_maxheap_two_classes_mod module~samplers_rejection_maxheap_two_classes_mod->module~lists_mod module~samplers_rejection_maxheap_two_classes_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_mod samplers_rejection_mod module~samplers_rejection_mod->module~lists_mod module~samplers_rejection_two_classes_mod samplers_rejection_two_classes_mod module~samplers_rejection_two_classes_mod->module~lists_mod module~samplers_rejection_two_classes_mod->module~samplers_rejection_mod proc~choose_sampler choose_sampler proc~choose_sampler->module~samplers_rejection_maxheap_composition_mod proc~choose_sampler->module~samplers_rejection_maxheap_mod proc~choose_sampler->module~samplers_rejection_maxheap_two_classes_mod proc~choose_sampler->module~samplers_rejection_mod proc~choose_sampler->module~samplers_rejection_two_classes_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface fixed_list Constructor for a fixed list private  function fixed_list_new(list) result(this) Create a new fixed list\nInput: list - an array of integers Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: list (:) Return Value type( fixed_list_t ) Derived Types type, public :: fixed_list_t Type for a fixed list, that can be used as a list of lists Components Type Visibility Attributes Name Initial integer(kind=i4), public :: initial_index Metadata integer(kind=i4), public :: final_index Metadata integer(kind=i4), public :: n = 0 integer(kind=i4), public, allocatable :: list (:) type( fixed_list_t ), public, pointer :: next type( fixed_list_t ), public, pointer :: prev Finalizations Procedures final :: finalize_fixed_list Type-Bound Procedures procedure, public :: init => fixed_list_init procedure, public :: sum => fixed_list_sum procedure, public :: print => fixed_list_print Functions public  function new_fixed_list_pointer (list) result(this) Create a new fixed list pointer\nInput: list - an array of integers Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: list (:) Return Value type( fixed_list_t ), pointer","tags":"","url":"module/lists_fixed_list_mod.html"},{"title":"samplers_rejection_maxheap_two_classes_mod – Data structures for Fortran","text":"This module implements rejection sampling with two classes\nWe split the weights into two classes based on a threshold Uses lists_mod samplers_rejection_maxheap_mod kinds_mod samplers_base_mod module~~samplers_rejection_maxheap_two_classes_mod~~UsesGraph module~samplers_rejection_maxheap_two_classes_mod samplers_rejection_maxheap_two_classes_mod module~kinds_mod kinds_mod module~samplers_rejection_maxheap_two_classes_mod->module~kinds_mod module~lists_mod lists_mod module~samplers_rejection_maxheap_two_classes_mod->module~lists_mod module~samplers_base_mod samplers_base_mod module~samplers_rejection_maxheap_two_classes_mod->module~samplers_base_mod module~samplers_rejection_maxheap_mod samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_two_classes_mod->module~samplers_rejection_maxheap_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env module~lists_mod->module~kinds_mod module~lists_dynamical_list_mod lists_dynamical_list_mod module~lists_mod->module~lists_dynamical_list_mod module~lists_fixed_list_mod lists_fixed_list_mod module~lists_mod->module~lists_fixed_list_mod module~maxheap_mod maxheap_mod module~lists_mod->module~maxheap_mod module~samplers_base_mod->module~kinds_mod module~samplers_rejection_maxheap_mod->module~kinds_mod module~samplers_rejection_maxheap_mod->module~lists_mod module~samplers_rejection_maxheap_mod->module~samplers_base_mod module~lists_dynamical_list_mod->module~kinds_mod module~lists_fixed_list_mod->module~kinds_mod module~maxheap_mod->module~kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~samplers_rejection_maxheap_two_classes_mod~~UsedByGraph module~samplers_rejection_maxheap_two_classes_mod samplers_rejection_maxheap_two_classes_mod proc~choose_sampler choose_sampler proc~choose_sampler->module~samplers_rejection_maxheap_two_classes_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface weighted_sampler Constructor private  function weighted_sampler_new(n) result(this) Create a new rejection sampler with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n Return Value type( weighted_sampler_t ) Derived Types type, public, extends( sampler_base_t ) :: weighted_sampler_t Derived type, extending from the base Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 type( weighted_sampler_t ), public :: samplers (2) real(kind=dp), public :: threshold = huge(dp) integer(kind=i4), public, allocatable :: sampler_of_index (:) Finalizations Procedures final :: sampler_finalize Type-Bound Procedures generic, public :: init => init_n , init_w , init_w2 procedure, public :: init_n => sampler_init procedure, public :: init_w => sampler_init_w procedure, public :: init_w2 => sampler_init_w2 procedure, public :: reset => sampler_reset procedure, public :: set_weight => sampler_set_weight procedure, public :: set_weight_array => sampler_set_weight_array procedure, public :: add_weight => sampler_add_weight procedure, public :: sample => sampler_sample procedure, public :: remove => sampler_remove procedure, public :: sum => sampler_sum","tags":"","url":"module/samplers_rejection_maxheap_two_classes_mod.html"},{"title":"samplers_btree_mod – Data structures for Fortran","text":"This modules implements a binary tree sampler\nIt provides a way to sample elements based on their weights using a binary tree structure. Uses samplers_base_mod kinds_mod module~~samplers_btree_mod~~UsesGraph module~samplers_btree_mod samplers_btree_mod module~kinds_mod kinds_mod module~samplers_btree_mod->module~kinds_mod module~samplers_base_mod samplers_base_mod module~samplers_btree_mod->module~samplers_base_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env module~samplers_base_mod->module~kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~samplers_btree_mod~~UsedByGraph module~samplers_btree_mod samplers_btree_mod module~samplers_rejection_maxheap_composition_mod samplers_rejection_maxheap_composition_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_btree_mod proc~choose_sampler choose_sampler proc~choose_sampler->module~samplers_btree_mod proc~choose_sampler->module~samplers_rejection_maxheap_composition_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface weighted_sampler Constructor private  function weighted_sampler_new(n) result(this) Create a new binary tree sampler with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n Return Value type( weighted_sampler_t ) Derived Types type, public, extends( sampler_base_t ) :: weighted_sampler_t Derived type, extending from the base Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 real(kind=dp), public, allocatable :: tree (:) Finalizations Procedures final :: sampler_finalize Type-Bound Procedures generic, public :: init => init_n , init_w , init_w2 procedure, public :: init_n => sampler_init procedure, public :: init_w => sampler_init_w procedure, public :: init_w2 => sampler_init_w2 procedure, public :: reset => sampler_reset procedure, public :: set_weight => sampler_set_weight procedure, public :: set_weight_array => sampler_set_weight_array procedure, public :: add_weight => sampler_add_weight procedure, public :: sample => sampler_sample procedure, public :: remove => sampler_remove procedure, public :: sum => sampler_sum","tags":"","url":"module/samplers_btree_mod.html"},{"title":"samplers_rejection_maxheap_mod – Data structures for Fortran","text":"Uses lists_mod kinds_mod samplers_base_mod module~~samplers_rejection_maxheap_mod~~UsesGraph module~samplers_rejection_maxheap_mod samplers_rejection_maxheap_mod module~kinds_mod kinds_mod module~samplers_rejection_maxheap_mod->module~kinds_mod module~lists_mod lists_mod module~samplers_rejection_maxheap_mod->module~lists_mod module~samplers_base_mod samplers_base_mod module~samplers_rejection_maxheap_mod->module~samplers_base_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env module~lists_mod->module~kinds_mod module~lists_dynamical_list_mod lists_dynamical_list_mod module~lists_mod->module~lists_dynamical_list_mod module~lists_fixed_list_mod lists_fixed_list_mod module~lists_mod->module~lists_fixed_list_mod module~maxheap_mod maxheap_mod module~lists_mod->module~maxheap_mod module~samplers_base_mod->module~kinds_mod module~lists_dynamical_list_mod->module~kinds_mod module~lists_fixed_list_mod->module~kinds_mod module~maxheap_mod->module~kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~samplers_rejection_maxheap_mod~~UsedByGraph module~samplers_rejection_maxheap_mod samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_composition_mod samplers_rejection_maxheap_composition_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_two_classes_mod samplers_rejection_maxheap_two_classes_mod module~samplers_rejection_maxheap_two_classes_mod->module~samplers_rejection_maxheap_mod proc~choose_sampler choose_sampler proc~choose_sampler->module~samplers_rejection_maxheap_mod proc~choose_sampler->module~samplers_rejection_maxheap_composition_mod proc~choose_sampler->module~samplers_rejection_maxheap_two_classes_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface weighted_sampler Constructor private  function weighted_sampler_new(n) result(this) Create a new rejection sampler with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n Return Value type( weighted_sampler_t ) Derived Types type, public, extends( sampler_base_t ) :: weighted_sampler_t Derived type, extending from the base Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 type( dynamical_list_t ), public, allocatable :: indices type( maxheap_t ), public, allocatable :: heap integer(kind=i4), public, allocatable :: position_of (:) real(kind=dp), public :: current_sum = 0.0_dp Finalizations Procedures final :: sampler_finalize Type-Bound Procedures generic, public :: init => init_n , init_w , init_w2 procedure, public :: init_n => sampler_init procedure, public :: init_w => sampler_init_w procedure, public :: init_w2 => sampler_init_w2 procedure, public :: reset => sampler_reset procedure, public :: set_weight => sampler_set_weight procedure, public :: set_weight_array => sampler_set_weight_array procedure, public :: add_weight => sampler_add_weight procedure, public :: sample => sampler_sample procedure, public :: remove => sampler_remove procedure, public :: sum => sampler_sum","tags":"","url":"module/samplers_rejection_maxheap_mod.html"},{"title":"samplers_base_mod – Data structures for Fortran","text":"This module implements the basic structure for weighted samplers Uses kinds_mod module~~samplers_base_mod~~UsesGraph module~samplers_base_mod samplers_base_mod module~kinds_mod kinds_mod module~samplers_base_mod->module~kinds_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~samplers_base_mod~~UsedByGraph module~samplers_base_mod samplers_base_mod module~datastructs_fortran datastructs_fortran module~datastructs_fortran->module~samplers_base_mod module~samplers_mod samplers_mod module~datastructs_fortran->module~samplers_mod module~samplers_btree_mod samplers_btree_mod module~samplers_btree_mod->module~samplers_base_mod module~samplers_mod->module~samplers_base_mod module~samplers_rejection_maxheap_composition_mod samplers_rejection_maxheap_composition_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_base_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_btree_mod module~samplers_rejection_maxheap_mod samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_mod->module~samplers_base_mod module~samplers_rejection_maxheap_two_classes_mod samplers_rejection_maxheap_two_classes_mod module~samplers_rejection_maxheap_two_classes_mod->module~samplers_base_mod module~samplers_rejection_maxheap_two_classes_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_mod samplers_rejection_mod module~samplers_rejection_mod->module~samplers_base_mod module~samplers_rejection_two_classes_mod samplers_rejection_two_classes_mod module~samplers_rejection_two_classes_mod->module~samplers_base_mod module~samplers_rejection_two_classes_mod->module~samplers_rejection_mod proc~choose_sampler choose_sampler proc~choose_sampler->module~samplers_btree_mod proc~choose_sampler->module~samplers_rejection_maxheap_composition_mod proc~choose_sampler->module~samplers_rejection_maxheap_mod proc~choose_sampler->module~samplers_rejection_maxheap_two_classes_mod proc~choose_sampler->module~samplers_rejection_mod proc~choose_sampler->module~samplers_rejection_two_classes_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public, abstract :: sampler_base_t Base type for all samplers Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 Type-Bound Procedures procedure(i_init_n), public, deferred :: init_n procedure(i_init_w), public, deferred :: init_w procedure(i_init_w2), public, deferred :: init_w2 generic, public :: init => init_n , init_w , init_w2 procedure(i_reset), public, deferred :: reset procedure(i_set_weight), public, deferred :: set_weight procedure(i_set_weight_array), public, deferred :: set_weight_array procedure(i_add_weight), public, deferred :: add_weight procedure(i_sample), public, deferred :: sample procedure(i_remove), public, deferred :: remove procedure(i_sum), public, deferred :: sum","tags":"","url":"module/samplers_base_mod.html"},{"title":"kinds_mod – Data structures for Fortran","text":"Uses iso_fortran_env module~~kinds_mod~~UsesGraph module~kinds_mod kinds_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~kinds_mod~~UsedByGraph module~kinds_mod kinds_mod module~hash_mod hash_mod module~hash_mod->module~kinds_mod module~lists_dynamical_list_mod lists_dynamical_list_mod module~lists_dynamical_list_mod->module~kinds_mod module~lists_fixed_list_mod lists_fixed_list_mod module~lists_fixed_list_mod->module~kinds_mod module~lists_mod lists_mod module~lists_mod->module~kinds_mod module~lists_mod->module~lists_dynamical_list_mod module~lists_mod->module~lists_fixed_list_mod module~maxheap_mod maxheap_mod module~lists_mod->module~maxheap_mod module~maxheap_mod->module~kinds_mod module~samplers_base_mod samplers_base_mod module~samplers_base_mod->module~kinds_mod module~samplers_btree_mod samplers_btree_mod module~samplers_btree_mod->module~kinds_mod module~samplers_btree_mod->module~samplers_base_mod module~samplers_mod samplers_mod module~samplers_mod->module~kinds_mod module~samplers_mod->module~samplers_base_mod module~samplers_rejection_maxheap_composition_mod samplers_rejection_maxheap_composition_mod module~samplers_rejection_maxheap_composition_mod->module~kinds_mod module~samplers_rejection_maxheap_composition_mod->module~lists_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_base_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_btree_mod module~samplers_rejection_maxheap_mod samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_mod->module~kinds_mod module~samplers_rejection_maxheap_mod->module~lists_mod module~samplers_rejection_maxheap_mod->module~samplers_base_mod module~samplers_rejection_maxheap_two_classes_mod samplers_rejection_maxheap_two_classes_mod module~samplers_rejection_maxheap_two_classes_mod->module~kinds_mod module~samplers_rejection_maxheap_two_classes_mod->module~lists_mod module~samplers_rejection_maxheap_two_classes_mod->module~samplers_base_mod module~samplers_rejection_maxheap_two_classes_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_mod samplers_rejection_mod module~samplers_rejection_mod->module~kinds_mod module~samplers_rejection_mod->module~lists_mod module~samplers_rejection_mod->module~samplers_base_mod module~samplers_rejection_two_classes_mod samplers_rejection_two_classes_mod module~samplers_rejection_two_classes_mod->module~kinds_mod module~samplers_rejection_two_classes_mod->module~lists_mod module~samplers_rejection_two_classes_mod->module~samplers_base_mod module~samplers_rejection_two_classes_mod->module~samplers_rejection_mod module~datastructs_fortran datastructs_fortran module~datastructs_fortran->module~hash_mod module~datastructs_fortran->module~lists_mod module~datastructs_fortran->module~samplers_base_mod module~datastructs_fortran->module~samplers_mod proc~choose_sampler choose_sampler proc~choose_sampler->module~samplers_btree_mod proc~choose_sampler->module~samplers_rejection_maxheap_composition_mod proc~choose_sampler->module~samplers_rejection_maxheap_mod proc~choose_sampler->module~samplers_rejection_maxheap_two_classes_mod proc~choose_sampler->module~samplers_rejection_mod proc~choose_sampler->module~samplers_rejection_two_classes_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: fmt_general = '(*(g0,x))' character(len=*), public, parameter :: fmt_comma = '(*(g0,\",\"))' Interfaces public        interface swap Interface for the swap subroutine. private  subroutine swap_int(a, b) Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(inout) :: a integer(kind=i4), intent(inout) :: b private  subroutine swap_real(a, b) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: a real(kind=dp), intent(inout) :: b Functions public  function choose_fmt_based_on (filename) result(fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value character(len=:), allocatable public  function count_integers_from_string (str) result(count) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer(kind=i4) Subroutines public  subroutine list_ranges () Arguments None","tags":"","url":"module/kinds_mod.html"},{"title":"hash_mod – Data structures for Fortran","text":"Uses kinds_mod module~~hash_mod~~UsesGraph module~hash_mod hash_mod module~kinds_mod kinds_mod module~hash_mod->module~kinds_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hash_mod~~UsedByGraph module~hash_mod hash_mod module~datastructs_fortran datastructs_fortran module~datastructs_fortran->module~hash_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function djb2 (list) result(r) DJB2 hash function\nInspired by http://www.cse.yorku.ca/~oz/hash.html\nand https://github.com/pdebuyl/fortran_hash_table/blob/master/src/dictionary_m.f90 Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: list (:) Return Value integer(kind=i8)","tags":"","url":"module/hash_mod.html"},{"title":"maxheap_mod – Data structures for Fortran","text":"This module implements a maxheap structure, keeping track of the maximum value and its index.\nExample: program example_maxheap use datastructs_fortran use kinds_mod implicit none type ( maxheap_t ) :: my_heap real ( kind = dp ), parameter :: list ( * ) = [ 4 0.0_dp , 2 5.5_dp , 3 0.1_dp , 10 0.4_dp , 2.0_dp ] integer ( kind = i4 ) :: i call my_heap % init ( 10 ) do i = 1 , size ( list ) call my_heap % add ( list ( i ), i ) end do call my_heap % print () call my_heap % remove ( 4 ) call my_heap % print () end program example_maxheap Uses kinds_mod module~~maxheap_mod~~UsesGraph module~maxheap_mod maxheap_mod module~kinds_mod kinds_mod module~maxheap_mod->module~kinds_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~maxheap_mod~~UsedByGraph module~maxheap_mod maxheap_mod module~lists_mod lists_mod module~lists_mod->module~maxheap_mod module~datastructs_fortran datastructs_fortran module~datastructs_fortran->module~lists_mod module~samplers_rejection_maxheap_composition_mod samplers_rejection_maxheap_composition_mod module~samplers_rejection_maxheap_composition_mod->module~lists_mod module~samplers_rejection_maxheap_mod samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_mod->module~lists_mod module~samplers_rejection_maxheap_two_classes_mod samplers_rejection_maxheap_two_classes_mod module~samplers_rejection_maxheap_two_classes_mod->module~lists_mod module~samplers_rejection_maxheap_two_classes_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_mod samplers_rejection_mod module~samplers_rejection_mod->module~lists_mod module~samplers_rejection_two_classes_mod samplers_rejection_two_classes_mod module~samplers_rejection_two_classes_mod->module~lists_mod module~samplers_rejection_two_classes_mod->module~samplers_rejection_mod proc~choose_sampler choose_sampler proc~choose_sampler->module~samplers_rejection_maxheap_composition_mod proc~choose_sampler->module~samplers_rejection_maxheap_mod proc~choose_sampler->module~samplers_rejection_maxheap_two_classes_mod proc~choose_sampler->module~samplers_rejection_mod proc~choose_sampler->module~samplers_rejection_two_classes_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface maxheap Constructor for a maxheap private  function maxheap_new(max_size) result(this) Create a new maxheap\nInput: max_size - maximum number of elements in the heap Arguments Type Intent Optional Attributes Name integer(kind=i4) :: max_size Return Value type( maxheap_t ) Derived Types type, public :: maxheap_t Type for a maxheap Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: values (:) integer(kind=i4), public, allocatable :: indices (:) integer(kind=i4), public, allocatable :: pos_of (:) integer(kind=i4), public :: n = 0 integer(kind=i4), public :: max_n Finalizations Procedures final :: maxheap_finalize Type-Bound Procedures procedure, public :: init => maxheap_init procedure, public :: add => maxheap_add procedure, public :: remove => maxheap_remove procedure, public :: add_weight => maxheap_add_weight procedure, public :: print => maxheap_print procedure, public :: max_value => maxheap_max_value procedure, public :: max_index => maxheap_max_index","tags":"","url":"module/maxheap_mod.html"},{"title":"lists_dynamical_list_mod – Data structures for Fortran","text":"This module implements a dynamical list, in which elements can be added or removed dynamically.\nIt assumes that there is a maximum size, and elements can be added or removed up to that size.\nExample: program test_dynamical_list use datastructs_fortran use kinds_mod implicit none type ( dynamical_list_t ) :: my_list integer ( kind = i4 ) :: i call my_list % init ( 10 ) do i = 1 , 10 call my_list % add ( i ) end do call my_list % print () call my_list % remove ( 5 ) call my_list % print () end program test_dynamical_list Uses kinds_mod module~~lists_dynamical_list_mod~~UsesGraph module~lists_dynamical_list_mod lists_dynamical_list_mod module~kinds_mod kinds_mod module~lists_dynamical_list_mod->module~kinds_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lists_dynamical_list_mod~~UsedByGraph module~lists_dynamical_list_mod lists_dynamical_list_mod module~lists_mod lists_mod module~lists_mod->module~lists_dynamical_list_mod module~datastructs_fortran datastructs_fortran module~datastructs_fortran->module~lists_mod module~samplers_rejection_maxheap_composition_mod samplers_rejection_maxheap_composition_mod module~samplers_rejection_maxheap_composition_mod->module~lists_mod module~samplers_rejection_maxheap_mod samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_mod->module~lists_mod module~samplers_rejection_maxheap_two_classes_mod samplers_rejection_maxheap_two_classes_mod module~samplers_rejection_maxheap_two_classes_mod->module~lists_mod module~samplers_rejection_maxheap_two_classes_mod->module~samplers_rejection_maxheap_mod module~samplers_rejection_mod samplers_rejection_mod module~samplers_rejection_mod->module~lists_mod module~samplers_rejection_two_classes_mod samplers_rejection_two_classes_mod module~samplers_rejection_two_classes_mod->module~lists_mod module~samplers_rejection_two_classes_mod->module~samplers_rejection_mod proc~choose_sampler choose_sampler proc~choose_sampler->module~samplers_rejection_maxheap_composition_mod proc~choose_sampler->module~samplers_rejection_maxheap_mod proc~choose_sampler->module~samplers_rejection_maxheap_two_classes_mod proc~choose_sampler->module~samplers_rejection_mod proc~choose_sampler->module~samplers_rejection_two_classes_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface dynamical_list Constructor for a dynamical list private  function dynamical_list_new(list) result(this) Create a new dynamical list\nInput: list - an array of integers\nOutput: a new dynamical list Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: list (:) Return Value type( dynamical_list_t ) Derived Types type, public :: dynamical_list_t List of integers with a given maximum fixed size\nThe first index is always 1, and filled up to n_used\nIt contains routines for managing the list Components Type Visibility Attributes Name Initial integer(kind=i4), public :: n = 0 integer(kind=i4), public :: n_used = 0 integer(kind=i4), public, allocatable :: list (:) Finalizations Procedures final :: finalize_dynamical_list Type-Bound Procedures procedure, public :: init => dynamical_list_init procedure, public :: reset => dynamical_list_reset procedure, public :: print => dynamical_list_print procedure, public :: expand => dynamical_list_expand procedure, public :: trim => dynamical_list_trim procedure, public :: last => dynamical_list_last procedure, public :: count => dynamical_list_count generic, public :: add => dynamical_list_add_element, dynamical_list_add_array generic, public :: remove => dynamical_list_remove_position, dynamical_list_remove_position_array, dynamical_list_remove_position_range generic, public :: assignment(=) => dynamical_list_create_from_array procedure, public :: get => dynamical_list_get procedure, public :: sum => dynamical_list_sum","tags":"","url":"module/lists_dynamical_list_mod.html"},{"title":"datastructs_fortran – Data structures for Fortran","text":"Hash functions Lists and maxheap constructors Derived types for lists and maxheap Utility functions for lists and maxheap Base type for all samplers Choose a sampler based on the selected algorithm Uses hash_mod lists_mod samplers_mod samplers_base_mod module~~datastructs_fortran~~UsesGraph module~datastructs_fortran datastructs_fortran module~hash_mod hash_mod module~datastructs_fortran->module~hash_mod module~lists_mod lists_mod module~datastructs_fortran->module~lists_mod module~samplers_base_mod samplers_base_mod module~datastructs_fortran->module~samplers_base_mod module~samplers_mod samplers_mod module~datastructs_fortran->module~samplers_mod module~kinds_mod kinds_mod module~hash_mod->module~kinds_mod module~lists_mod->module~kinds_mod module~lists_dynamical_list_mod lists_dynamical_list_mod module~lists_mod->module~lists_dynamical_list_mod module~lists_fixed_list_mod lists_fixed_list_mod module~lists_mod->module~lists_fixed_list_mod module~maxheap_mod maxheap_mod module~lists_mod->module~maxheap_mod module~samplers_base_mod->module~kinds_mod module~samplers_mod->module~samplers_base_mod module~samplers_mod->module~kinds_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env module~lists_dynamical_list_mod->module~kinds_mod module~lists_fixed_list_mod->module~kinds_mod module~maxheap_mod->module~kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses.","tags":"","url":"module/datastructs_fortran.html"},{"title":"samplers_rejection_maxheap_composition_mod – Data structures for Fortran","text":"This module implements a rejection composition sampler\nIt is based on \"St-Onge, G., Young, J. G., Hébert-Dufresne, L., & Dubé, L. J. (2019).\nEfficient sampling of spreading processes on complex networks using a composition and rejection algorithm.\nComputer physics communications, 240, 30-37\" https://doi.org/10.1016/j.cpc.2019.02.008 Uses lists_mod samplers_rejection_maxheap_mod samplers_base_mod samplers_btree_mod kinds_mod module~~samplers_rejection_maxheap_composition_mod~~UsesGraph module~samplers_rejection_maxheap_composition_mod samplers_rejection_maxheap_composition_mod module~kinds_mod kinds_mod module~samplers_rejection_maxheap_composition_mod->module~kinds_mod module~lists_mod lists_mod module~samplers_rejection_maxheap_composition_mod->module~lists_mod module~samplers_base_mod samplers_base_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_base_mod module~samplers_btree_mod samplers_btree_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_btree_mod module~samplers_rejection_maxheap_mod samplers_rejection_maxheap_mod module~samplers_rejection_maxheap_composition_mod->module~samplers_rejection_maxheap_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env module~lists_mod->module~kinds_mod module~lists_dynamical_list_mod lists_dynamical_list_mod module~lists_mod->module~lists_dynamical_list_mod module~lists_fixed_list_mod lists_fixed_list_mod module~lists_mod->module~lists_fixed_list_mod module~maxheap_mod maxheap_mod module~lists_mod->module~maxheap_mod module~samplers_base_mod->module~kinds_mod module~samplers_btree_mod->module~kinds_mod module~samplers_btree_mod->module~samplers_base_mod module~samplers_rejection_maxheap_mod->module~kinds_mod module~samplers_rejection_maxheap_mod->module~lists_mod module~samplers_rejection_maxheap_mod->module~samplers_base_mod module~lists_dynamical_list_mod->module~kinds_mod module~lists_fixed_list_mod->module~kinds_mod module~maxheap_mod->module~kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~samplers_rejection_maxheap_composition_mod~~UsedByGraph module~samplers_rejection_maxheap_composition_mod samplers_rejection_maxheap_composition_mod proc~choose_sampler choose_sampler proc~choose_sampler->module~samplers_rejection_maxheap_composition_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface weighted_sampler Constructor private  function weighted_sampler_new(n) result(this) Create a new sampler with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n Return Value type( weighted_sampler_t ) Derived Types type, public, extends( sampler_base_t ) :: weighted_sampler_t Derived type, extending from the base Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 type( weighted_sampler_t ), public, allocatable :: samplers (:) integer(kind=i4), public :: q = 0 type( weighted_sampler_t ), public :: btree integer(kind=i4), public, allocatable :: sampler_of_index (:) real(kind=dp), public :: wmin real(kind=dp), public :: wmax Finalizations Procedures final :: sampler_finalize Type-Bound Procedures generic, public :: init => init_n , init_w , init_w2 procedure, public :: init_n => sampler_init procedure, public :: init_w => sampler_init_w procedure, public :: init_w2 => sampler_init_w2 procedure, public :: reset => sampler_reset procedure, public :: set_weight => sampler_set_weight procedure, public :: set_weight_array => sampler_set_weight_array procedure, public :: add_weight => sampler_add_weight procedure, public :: sample => sampler_sample procedure, public :: remove => sampler_remove procedure, public :: sum => sampler_sum procedure, public :: sampler_pos => sampler_sampler_pos","tags":"","url":"module/samplers_rejection_maxheap_composition_mod.html"},{"title":"samplers_rejection_two_classes_mod – Data structures for Fortran","text":"This module implements rejection sampling with two classes\nWe split the weights into two classes based on a threshold Uses lists_mod kinds_mod samplers_rejection_mod samplers_base_mod module~~samplers_rejection_two_classes_mod~~UsesGraph module~samplers_rejection_two_classes_mod samplers_rejection_two_classes_mod module~kinds_mod kinds_mod module~samplers_rejection_two_classes_mod->module~kinds_mod module~lists_mod lists_mod module~samplers_rejection_two_classes_mod->module~lists_mod module~samplers_base_mod samplers_base_mod module~samplers_rejection_two_classes_mod->module~samplers_base_mod module~samplers_rejection_mod samplers_rejection_mod module~samplers_rejection_two_classes_mod->module~samplers_rejection_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env module~lists_mod->module~kinds_mod module~lists_dynamical_list_mod lists_dynamical_list_mod module~lists_mod->module~lists_dynamical_list_mod module~lists_fixed_list_mod lists_fixed_list_mod module~lists_mod->module~lists_fixed_list_mod module~maxheap_mod maxheap_mod module~lists_mod->module~maxheap_mod module~samplers_base_mod->module~kinds_mod module~samplers_rejection_mod->module~kinds_mod module~samplers_rejection_mod->module~lists_mod module~samplers_rejection_mod->module~samplers_base_mod module~lists_dynamical_list_mod->module~kinds_mod module~lists_fixed_list_mod->module~kinds_mod module~maxheap_mod->module~kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~samplers_rejection_two_classes_mod~~UsedByGraph module~samplers_rejection_two_classes_mod samplers_rejection_two_classes_mod proc~choose_sampler choose_sampler proc~choose_sampler->module~samplers_rejection_two_classes_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface weighted_sampler Constructor private  function weighted_sampler_new(n) result(this) Create a new rejection sampler with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n Return Value type( weighted_sampler_t ) Derived Types type, public, extends( sampler_base_t ) :: weighted_sampler_t Derived type, extending from the base Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 type( weighted_sampler_t ), public :: samplers (2) real(kind=dp), public :: threshold = huge(dp) integer(kind=i4), public, allocatable :: sampler_of_index (:) Finalizations Procedures final :: sampler_finalize Type-Bound Procedures generic, public :: init => init_n , init_w , init_w2 procedure, public :: init_n => sampler_init procedure, public :: init_w => sampler_init_w procedure, public :: init_w2 => sampler_init_w2 procedure, public :: reset => sampler_reset procedure, public :: set_weight => sampler_set_weight procedure, public :: set_weight_array => sampler_set_weight_array procedure, public :: add_weight => sampler_add_weight procedure, public :: sample => sampler_sample procedure, public :: remove => sampler_remove procedure, public :: sum => sampler_sum","tags":"","url":"module/samplers_rejection_two_classes_mod.html"},{"title":"samplers_rejection_mod – Data structures for Fortran","text":"This module implements a rejection sampling Uses lists_mod kinds_mod samplers_base_mod module~~samplers_rejection_mod~~UsesGraph module~samplers_rejection_mod samplers_rejection_mod module~kinds_mod kinds_mod module~samplers_rejection_mod->module~kinds_mod module~lists_mod lists_mod module~samplers_rejection_mod->module~lists_mod module~samplers_base_mod samplers_base_mod module~samplers_rejection_mod->module~samplers_base_mod iso_fortran_env iso_fortran_env module~kinds_mod->iso_fortran_env module~lists_mod->module~kinds_mod module~lists_dynamical_list_mod lists_dynamical_list_mod module~lists_mod->module~lists_dynamical_list_mod module~lists_fixed_list_mod lists_fixed_list_mod module~lists_mod->module~lists_fixed_list_mod module~maxheap_mod maxheap_mod module~lists_mod->module~maxheap_mod module~samplers_base_mod->module~kinds_mod module~lists_dynamical_list_mod->module~kinds_mod module~lists_fixed_list_mod->module~kinds_mod module~maxheap_mod->module~kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~samplers_rejection_mod~~UsedByGraph module~samplers_rejection_mod samplers_rejection_mod module~samplers_rejection_two_classes_mod samplers_rejection_two_classes_mod module~samplers_rejection_two_classes_mod->module~samplers_rejection_mod proc~choose_sampler choose_sampler proc~choose_sampler->module~samplers_rejection_mod proc~choose_sampler->module~samplers_rejection_two_classes_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface weighted_sampler Constructor private  function weighted_sampler_new(n) result(this) Create a new rejection sampler with N weights\nInput: n - number of weights Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n Return Value type( weighted_sampler_t ) Derived Types type, public, extends( sampler_base_t ) :: weighted_sampler_t Derived type, extending from the base Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: weights (:) integer(kind=i4), public :: n = 0 type( dynamical_list_t ), public, allocatable :: indices integer(kind=i4), public, allocatable :: position_of (:) real(kind=dp), public :: current_sum = 0.0_dp real(kind=dp), public :: max_weight = 0.0_dp Finalizations Procedures final :: sampler_finalize Type-Bound Procedures generic, public :: init => init_n , init_w , init_w2 procedure, public :: init_n => sampler_init procedure, public :: init_w => sampler_init_w procedure, public :: init_w2 => sampler_init_w2 procedure, public :: reset => sampler_reset procedure, public :: set_weight => sampler_set_weight procedure, public :: set_weight_array => sampler_set_weight_array procedure, public :: add_weight => sampler_add_weight procedure, public :: sample => sampler_sample procedure, public :: remove => sampler_remove procedure, public :: sum => sampler_sum","tags":"","url":"module/samplers_rejection_mod.html"},{"title":"samplers.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~samplers.f90~~EfferentGraph sourcefile~samplers.f90 samplers.f90 sourcefile~base.f90 base.f90 sourcefile~samplers.f90->sourcefile~base.f90 sourcefile~btree.f90 btree.f90 sourcefile~samplers.f90->sourcefile~btree.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~samplers.f90->sourcefile~kinds.f90 sourcefile~rejection.f90 rejection.f90 sourcefile~samplers.f90->sourcefile~rejection.f90 sourcefile~rejection_maxheap.f90 rejection_maxheap.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_maxheap_composition.f90 rejection_maxheap_composition.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_composition.f90 sourcefile~rejection_maxheap_two_classes.f90 rejection_maxheap_two_classes.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_two_classes.f90 sourcefile~rejection_two_classes.f90 rejection_two_classes.f90 sourcefile~samplers.f90->sourcefile~rejection_two_classes.f90 sourcefile~base.f90->sourcefile~kinds.f90 sourcefile~btree.f90->sourcefile~base.f90 sourcefile~btree.f90->sourcefile~kinds.f90 sourcefile~rejection.f90->sourcefile~base.f90 sourcefile~rejection.f90->sourcefile~kinds.f90 sourcefile~lists.f90 lists.f90 sourcefile~rejection.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap.f90->sourcefile~base.f90 sourcefile~rejection_maxheap.f90->sourcefile~kinds.f90 sourcefile~rejection_maxheap.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~base.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~btree.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~kinds.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~base.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~kinds.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_two_classes.f90->sourcefile~base.f90 sourcefile~rejection_two_classes.f90->sourcefile~kinds.f90 sourcefile~rejection_two_classes.f90->sourcefile~rejection.f90 sourcefile~rejection_two_classes.f90->sourcefile~lists.f90 sourcefile~lists.f90->sourcefile~kinds.f90 sourcefile~dynamical_list.f90 dynamical_list.f90 sourcefile~lists.f90->sourcefile~dynamical_list.f90 sourcefile~fixed_list.f90 fixed_list.f90 sourcefile~lists.f90->sourcefile~fixed_list.f90 sourcefile~maxheap.f90 maxheap.f90 sourcefile~lists.f90->sourcefile~maxheap.f90 sourcefile~dynamical_list.f90->sourcefile~kinds.f90 sourcefile~fixed_list.f90->sourcefile~kinds.f90 sourcefile~maxheap.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~samplers.f90~~AfferentGraph sourcefile~samplers.f90 samplers.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Module to select an weighted sampler !> The idea is that it contains the list of indexes up to a size n, !> and each index has an weight !> The sampling is done proportionally to the weights. !> It depends on the `rndgen-fortran` module, found at <https://github.com/wcota/rndgen-fortran> !> Each sampler algorithm is implemented separately. !> !> Example: !> ```fortran !> program example_sampler !>     use datastructs_fortran !>     use kinds_mod !>     use rndgen_mod !>     implicit none !> !>     type(rndgen) :: gen !>     class(sampler_base_t), allocatable :: my_sampler !>     integer(kind=i4) :: i !>     real(kind=dp), parameter :: weights(*) = [100.0_dp, 50.0_dp, 200.0_dp, 25.0_dp] !>     integer(kind=i4), allocatable :: count_times(:) !>     integer(kind=i4) :: selected_index !>     integer(kind=i4), parameter :: n_samples = 10000 !> !>     ! choose the sampler algorithm !>     call choose_sampler(my_sampler, 'btree') !>     call my_sampler%init(size(weights)) !>     call my_sampler%set_weight_array(weights) !> !>     ! initialize the random generator with a seed !>     call gen%init(12345) !> !>     ! count the number of times each element was selected !>     allocate(count_times(size(weights))) !>     count_times = 0 !> !>     ! Sample from the distribution !>     do i = 1, n_samples !>         selected_index = my_sampler%sample(gen) !>         !write(*, fmt_general) \"Selected index:\", selected_index !>         count_times(selected_index) = count_times(selected_index) + 1 !>     end do !> !>     ! Print the result !>     write(*, fmt_general) \"For n_samples = \", n_samples !>     do i = 1, size(weights) !>         write(*, fmt_general) \"@ Index:\", i, \" Weight:\", weights(i), \"Count:\", count_times(i), \"Prob:\", 1.0_dp * count_times(i) / sum(count_times), \"Expected prob:\", weights(i) / sum(weights) !>     end do !> end program example_sampler !> ``` module samplers_mod use kinds_mod use samplers_base_mod , only : sampler_base_t implicit none private !> List of available sampler algorithms character ( len =* ), parameter :: samplers_choices = 'btree,rejection,rejection_two_classes,rejection_maxheap,rejection_maxheap_two_classes,rejection_maxheap_composition' public :: choose_sampler , samplers_choices contains !> Subroutine to allocate a `class(sampler_base_t)` to its respective object subroutine choose_sampler ( weighted_sampler , selected_algorithm ) ! imports the different weighted samplers based on the selected algorithm use samplers_btree_mod , only : weighted_sampler_btree_t => weighted_sampler_t use samplers_rejection_mod , only : weighted_sampler_rejection_t => weighted_sampler_t use samplers_rejection_two_classes_mod , only : weighted_sampler_rejection_two_classes_t => weighted_sampler_t use samplers_rejection_maxheap_mod , only : weighted_sampler_rejection_maxheap_t => weighted_sampler_t use samplers_rejection_maxheap_two_classes_mod , only : weighted_sampler_rejection_maxheap_two_classes_t => weighted_sampler_t use samplers_rejection_maxheap_composition_mod , only : weighted_sampler_rejection_maxheap_composition_t => weighted_sampler_t class ( sampler_base_t ), allocatable , intent ( out ) :: weighted_sampler character ( len =* ), intent ( in ) :: selected_algorithm select case ( trim ( adjustl ( selected_algorithm ))) case ( 'btree' ) allocate ( weighted_sampler_btree_t :: weighted_sampler ) case ( 'rejection' ) allocate ( weighted_sampler_rejection_t :: weighted_sampler ) case ( 'rejection_maxheap' ) allocate ( weighted_sampler_rejection_maxheap_t :: weighted_sampler ) case ( 'rejection_two_classes' ) allocate ( weighted_sampler_rejection_two_classes_t :: weighted_sampler ) case ( 'rejection_maxheap_two_classes' ) allocate ( weighted_sampler_rejection_maxheap_two_classes_t :: weighted_sampler ) case ( 'rejection_maxheap_composition' ) allocate ( weighted_sampler_rejection_maxheap_composition_t :: weighted_sampler ) case default error stop 'Unknown algorithm selected: ' // trim ( adjustl ( selected_algorithm )) end select end subroutine choose_sampler end module samplers_mod","tags":"","url":"sourcefile/samplers.f90.html"},{"title":"lists.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~lists.f90~~EfferentGraph sourcefile~lists.f90 lists.f90 sourcefile~dynamical_list.f90 dynamical_list.f90 sourcefile~lists.f90->sourcefile~dynamical_list.f90 sourcefile~fixed_list.f90 fixed_list.f90 sourcefile~lists.f90->sourcefile~fixed_list.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~lists.f90->sourcefile~kinds.f90 sourcefile~maxheap.f90 maxheap.f90 sourcefile~lists.f90->sourcefile~maxheap.f90 sourcefile~dynamical_list.f90->sourcefile~kinds.f90 sourcefile~fixed_list.f90->sourcefile~kinds.f90 sourcefile~maxheap.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~lists.f90~~AfferentGraph sourcefile~lists.f90 lists.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~lists.f90 sourcefile~samplers.f90 samplers.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 sourcefile~rejection.f90 rejection.f90 sourcefile~rejection.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap.f90 rejection_maxheap.f90 sourcefile~rejection_maxheap.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_composition.f90 rejection_maxheap_composition.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_maxheap_two_classes.f90 rejection_maxheap_two_classes.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_two_classes.f90 rejection_two_classes.f90 sourcefile~rejection_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_two_classes.f90->sourcefile~rejection.f90 sourcefile~samplers.f90->sourcefile~rejection.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_composition.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_two_classes.f90 sourcefile~samplers.f90->sourcefile~rejection_two_classes.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> General module for lists and related operations module lists_mod use kinds_mod use lists_dynamical_list_mod use lists_fixed_list_mod use maxheap_mod implicit none private !> Constructors public :: dynamical_list , fixed_list , maxheap !> Derived types public :: dynamical_list_t , fixed_list_t , maxheap_t !> Operations public :: unique_values public :: new_fixed_list_pointer contains !> Find unique values in a list of integers !> It uses the standard library sorting module !> The result is a list of unique integers function unique_values ( list ) result ( unique ) use stdlib_sorting , only : sort integer ( kind = i4 ), intent ( in ) :: list (:) integer ( kind = i4 ), allocatable :: unique (:) integer ( kind = i4 ), allocatable :: sorted_list (:) integer ( kind = i4 ) :: i , count_unique sorted_list = list call sort ( sorted_list ) count_unique = 1 do i = 2 , size ( sorted_list ) if ( sorted_list ( i ) /= sorted_list ( i - 1 )) count_unique = count_unique + 1 end do ! get the unique values allocate ( unique ( count_unique )) unique ( 1 ) = sorted_list ( 1 ) count_unique = 1 do i = 2 , size ( sorted_list ) if ( sorted_list ( i ) /= sorted_list ( i - 1 )) then count_unique = count_unique + 1 unique ( count_unique ) = sorted_list ( i ) end if end do end function unique_values end module","tags":"","url":"sourcefile/lists.f90.html"},{"title":"fixed_list.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~fixed_list.f90~~EfferentGraph sourcefile~fixed_list.f90 fixed_list.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~fixed_list.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~fixed_list.f90~~AfferentGraph sourcefile~fixed_list.f90 fixed_list.f90 sourcefile~lists.f90 lists.f90 sourcefile~lists.f90->sourcefile~fixed_list.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~lists.f90 sourcefile~samplers.f90 samplers.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 sourcefile~rejection.f90 rejection.f90 sourcefile~rejection.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap.f90 rejection_maxheap.f90 sourcefile~rejection_maxheap.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_composition.f90 rejection_maxheap_composition.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_maxheap_two_classes.f90 rejection_maxheap_two_classes.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_two_classes.f90 rejection_two_classes.f90 sourcefile~rejection_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_two_classes.f90->sourcefile~rejection.f90 sourcefile~samplers.f90->sourcefile~rejection.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_composition.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_two_classes.f90 sourcefile~samplers.f90->sourcefile~rejection_two_classes.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> This module implements a fixed list, that has a fixed size and cannot be resized. !> It also has pointers, allowing to build a linked list structure. !> Example: !> ```fortran !> program example_fixed_list !>     use datastructs_fortran !>     use kinds_mod !>     implicit none !>     type(fixed_list_t) :: my_list !>     type(fixed_list_t), target :: my_list2 !>     my_list = fixed_list([1,2,3,4,5]) !>     my_list2 = fixed_list([6,7,8]) !> !>     call my_list%print() !> !>     my_list%next => my_list2 !> !>     call my_list%next%print() !> end program example_fixed_list !> ``` module lists_fixed_list_mod use kinds_mod implicit none private !> Constructor for a fixed list interface fixed_list module procedure fixed_list_new end interface fixed_list !> Type for a fixed list, that can be used as a list of lists type :: fixed_list_t !> Metadata integer ( kind = i4 ) :: initial_index , final_index integer ( kind = i4 ) :: n = 0 integer ( kind = i4 ), allocatable :: list (:) ! Pointers for the linked list ! It can be used to create a list of lists with different sizes type ( fixed_list_t ), pointer :: next , prev contains procedure :: init => fixed_list_init ! initialize the list procedure :: sum => fixed_list_sum ! sum the elements procedure :: print => fixed_list_print ! print the list final :: finalize_fixed_list ! finalize the list end type public :: fixed_list , new_fixed_list_pointer , fixed_list_t contains !> Create a new fixed list !> Input: list - an array of integers function fixed_list_new ( list ) result ( this ) type ( fixed_list_t ) :: this integer ( kind = i4 ), intent ( in ) :: list (:) ! allocate the fixed list this % initial_index = 1 this % final_index = size ( list ) this % list = list ! set the size of the list this % n = size ( list ) end function fixed_list_new !> Create a new fixed list pointer !> Input: list - an array of integers function new_fixed_list_pointer ( list ) result ( this ) type ( fixed_list_t ), pointer :: this integer ( kind = i4 ), intent ( in ) :: list (:) this % initial_index = 1 this % final_index = size ( list ) this % list = list ! set the size of the list this % n = size ( list ) end function new_fixed_list_pointer !> Initialize the fixed list !> Input: i1 - initial index, i2 - final index !>        If i2 is not present, i1 is used as the size (final index) subroutine fixed_list_init ( this , i1 , i2 ) class ( fixed_list_t ), intent ( inout ) :: this integer ( kind = i4 ), intent ( in ) :: i1 integer ( kind = i4 ), intent ( in ), optional :: i2 integer ( kind = i4 ) :: ini_index , fin_index if ( present ( i2 )) then ini_index = i1 fin_index = i2 else ini_index = 1 fin_index = i1 end if this % initial_index = ini_index this % final_index = fin_index allocate ( this % list ( ini_index : fin_index )) this % n = fin_index - ini_index + 1 end subroutine fixed_list_init !> Sum the elements of the fixed list function fixed_list_sum ( this ) result ( val ) class ( fixed_list_t ), intent ( in ) :: this integer ( kind = i4 ) :: val val = sum ( this % list ( this % initial_index : this % final_index )) end function fixed_list_sum !> Print the fixed list subroutine fixed_list_print ( this ) class ( fixed_list_t ), intent ( in ) :: this write ( * , fmt_general ) '(initial_index = ' , this % initial_index , ', final_index = ' , this % final_index , ')' , this % list end subroutine fixed_list_print !> Finalize the list subroutine finalize_fixed_list ( this ) type ( fixed_list_t ), intent ( inout ) :: this if ( allocated ( this % list )) deallocate ( this % list ) end subroutine finalize_fixed_list end module lists_fixed_list_mod","tags":"","url":"sourcefile/fixed_list.f90.html"},{"title":"rejection_maxheap_two_classes.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~rejection_maxheap_two_classes.f90~~EfferentGraph sourcefile~rejection_maxheap_two_classes.f90 rejection_maxheap_two_classes.f90 sourcefile~base.f90 base.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~base.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~kinds.f90 sourcefile~lists.f90 lists.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap.f90 rejection_maxheap.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~rejection_maxheap.f90 sourcefile~base.f90->sourcefile~kinds.f90 sourcefile~lists.f90->sourcefile~kinds.f90 sourcefile~dynamical_list.f90 dynamical_list.f90 sourcefile~lists.f90->sourcefile~dynamical_list.f90 sourcefile~fixed_list.f90 fixed_list.f90 sourcefile~lists.f90->sourcefile~fixed_list.f90 sourcefile~maxheap.f90 maxheap.f90 sourcefile~lists.f90->sourcefile~maxheap.f90 sourcefile~rejection_maxheap.f90->sourcefile~base.f90 sourcefile~rejection_maxheap.f90->sourcefile~kinds.f90 sourcefile~rejection_maxheap.f90->sourcefile~lists.f90 sourcefile~dynamical_list.f90->sourcefile~kinds.f90 sourcefile~fixed_list.f90->sourcefile~kinds.f90 sourcefile~maxheap.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~rejection_maxheap_two_classes.f90~~AfferentGraph sourcefile~rejection_maxheap_two_classes.f90 rejection_maxheap_two_classes.f90 sourcefile~samplers.f90 samplers.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_two_classes.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> This module implements rejection sampling with two classes !> We split the weights into two classes based on a threshold module samplers_rejection_maxheap_two_classes_mod use kinds_mod use lists_mod use samplers_rejection_maxheap_mod , only : rejection_maxheap_t => weighted_sampler_t use samplers_base_mod implicit none private !> Constructor interface weighted_sampler module procedure weighted_sampler_new end interface weighted_sampler !> Derived type, extending from the base type , extends ( sampler_base_t ) :: weighted_sampler_t type ( rejection_maxheap_t ) :: samplers ( 2 ) real ( dp ) :: threshold = huge ( dp ) ! threshold for the weights integer ( i4 ), allocatable :: sampler_of_index (:) ! maps index to sampler (1 or 2) contains procedure :: init_n => sampler_init procedure :: init_w => sampler_init_w procedure :: init_w2 => sampler_init_w2 procedure :: reset => sampler_reset procedure :: set_weight => sampler_set_weight procedure :: set_weight_array => sampler_set_weight_array procedure :: add_weight => sampler_add_weight procedure :: sample => sampler_sample procedure :: remove => sampler_remove procedure :: sum => sampler_sum final :: sampler_finalize end type public :: weighted_sampler , weighted_sampler_t contains !> Create a new rejection sampler with N weights !> Input: n - number of weights function weighted_sampler_new ( n ) result ( this ) type ( weighted_sampler_t ) :: this integer ( i4 ), intent ( in ) :: n call this % init ( n ) end function weighted_sampler_new !> Initializes the structure with N weights !> Input: n - number of weights subroutine sampler_init ( this , n ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n this % n = n ! Set the number of weights ! init each sampler with size n call this % samplers ( 1 )% init ( n ) call this % samplers ( 2 )% init ( n ) allocate ( this % sampler_of_index ( n )) allocate ( this % weights ( n )) this % sampler_of_index = 0 ! Initialize to zero (no sampler assigned yet) this % weights = 0.0_dp ! Initialize weights to zero end subroutine sampler_init !> Initializes with size n and threshold w !> Input: n - number of weights !>        w - threshold for the weights subroutine sampler_init_w ( this , n , w ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w call this % init ( n ) ! call original init this % threshold = w ! set the threshold for the weights end subroutine sampler_init_w !> Placeholder for 1D initialization (compat mode), maps to original init !> Input: n - number of weights !>        w1 - any real number, not used !>        w2 - any real number, not used subroutine sampler_init_w2 ( this , n , w1 , w2 ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w1 , w2 call this % init ( n , w1 ) ! call original init end subroutine sampler_init_w2 !> Resets the sampler: clears the list subroutine sampler_reset ( this ) class ( weighted_sampler_t ), intent ( inout ) :: this call this % samplers ( 1 )% reset () ! Reset the first sampler call this % samplers ( 2 )% reset () ! Reset the second sampler this % sampler_of_index = 0 ! Reset the index mapping this % weights = 0.0_dp ! Reset the weights end subroutine sampler_reset !> Sets the weight for a given index !> Input: index - index of the element with a given weight !>        weight - weight of the element subroutine sampler_set_weight ( this , index , weight ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: weight integer ( i4 ) :: old_sampler_pos ! get the sampler pos old_sampler_pos = this % sampler_of_index ( index ) ! We select which sampler will receive the weight based on the threshold ! The first sampler will receive weights below the threshold ! The second sampler will receive weights above the threshold if ( weight < this % threshold ) then call this % samplers ( 1 )% set_weight ( index , weight ) ! Set the weight in the first sampler this % sampler_of_index ( index ) = 1 ! Map index to first sampler ! If it was in the second sampler, we need to remove it if ( old_sampler_pos == 2 ) call this % samplers ( 2 )% remove ( index ) else call this % samplers ( 2 )% set_weight ( index , weight ) ! Set the weight in the second sampler this % sampler_of_index ( index ) = 2 ! Map index to second sampler ! If it was in the first sampler, we need to remove it if ( old_sampler_pos == 1 ) call this % samplers ( 1 )% remove ( index ) end if ! update the weights array this % weights ( index ) = weight end subroutine sampler_set_weight !> Sets the weights from an array (full), using its indexes !> Weights should be larger than zero !> It assumes it was initialized before, and has the same size !> Input: weights - array with the weights subroutine sampler_set_weight_array ( this , weights ) class ( weighted_sampler_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: weights (:) integer ( i4 ) :: i ! We select which sampler will receive the weights based on the threshold ! The first sampler will receive weights below the threshold ! The second sampler will receive weights above the threshold do i = 1 , size ( weights ) call this % set_weight ( i , weights ( i )) end do end subroutine sampler_set_weight_array !> Adds a weight to the sampler at a given index !> Input: index - index of the element !>        delta_weight - difference to add to its weight subroutine sampler_add_weight ( this , index , delta_weight ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: delta_weight real ( dp ) :: weight weight = this % weights ( index ) + delta_weight ! Calculate the new weight ! we first remove the element call this % remove ( index ) ! Remove the index from the sampler ! Now we can add the weight again call this % set_weight ( index , weight ) ! Set the new weight end subroutine sampler_add_weight !> Remove an index from the sampler !> Important: the index is the original one, not the index used internally by the sampler !> Input: index - index of the element to be removed subroutine sampler_remove ( this , index ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index integer ( i4 ) :: sampler_pos sampler_pos = this % sampler_of_index ( index ) ! Get the sampler position for the index if ( sampler_pos == 0 ) return ! It is not mapped to any sampler, just ignore call this % samplers ( sampler_pos )% remove ( index ) ! Remove weight in the first sampler this % sampler_of_index ( index ) = 0 ! Unmap index ! update the weights array this % weights ( index ) = 0.0_dp ! Set the weight to zero end subroutine sampler_remove !> Samples an index from the sampler !> Input: gen - random number generator (rndgen-fortran module) !> Output: index - sampled index function sampler_sample ( this , gen ) result ( index ) use rndgen_mod class ( weighted_sampler_t ), intent ( in ) :: this class ( rndgen ), intent ( inout ) :: gen integer ( i4 ) :: index real ( dp ) :: total_weight total_weight = this % sum () ! We will use rejection sampling to select an index ! First, we see which sampler to use based on the total weight if ( gen % rnd () < this % samplers ( 1 )% sum () / total_weight ) then ! Use the first sampler index = this % samplers ( 1 )% sample ( gen ) else ! Use the second sampler index = this % samplers ( 2 )% sample ( gen ) end if end function !> Get the sum of all weights !> Output: total - sum of all weights function sampler_sum ( this ) result ( total_weight ) class ( weighted_sampler_t ), intent ( in ) :: this real ( dp ) :: total_weight total_weight = this % samplers ( 1 )% sum () + this % samplers ( 2 )% sum () end function sampler_sum !> Finalize the sampler, deallocate resources subroutine sampler_finalize ( this ) type ( weighted_sampler_t ), intent ( inout ) :: this if ( allocated ( this % sampler_of_index )) then deallocate ( this % sampler_of_index ) end if if ( allocated ( this % weights )) then deallocate ( this % weights ) end if end subroutine sampler_finalize end module samplers_rejection_maxheap_two_classes_mod","tags":"","url":"sourcefile/rejection_maxheap_two_classes.f90.html"},{"title":"btree.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~btree.f90~~EfferentGraph sourcefile~btree.f90 btree.f90 sourcefile~base.f90 base.f90 sourcefile~btree.f90->sourcefile~base.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~btree.f90->sourcefile~kinds.f90 sourcefile~base.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~btree.f90~~AfferentGraph sourcefile~btree.f90 btree.f90 sourcefile~rejection_maxheap_composition.f90 rejection_maxheap_composition.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~btree.f90 sourcefile~samplers.f90 samplers.f90 sourcefile~samplers.f90->sourcefile~btree.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_composition.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> This modules implements a binary tree sampler !> It provides a way to sample elements based on their weights using a binary tree structure. module samplers_btree_mod use kinds_mod use samplers_base_mod implicit none private !> Constructor interface weighted_sampler module procedure weighted_sampler_new end interface !> Derived type, extending from the base type , extends ( sampler_base_t ) :: weighted_sampler_t real ( dp ), allocatable :: tree (:) ! soma das subárvores contains procedure :: init_n => sampler_init procedure :: init_w => sampler_init_w procedure :: init_w2 => sampler_init_w2 procedure :: reset => sampler_reset procedure :: set_weight => sampler_set_weight procedure :: set_weight_array => sampler_set_weight_array procedure :: add_weight => sampler_add_weight procedure :: sample => sampler_sample procedure :: remove => sampler_remove procedure :: sum => sampler_sum final :: sampler_finalize end type weighted_sampler_t public :: weighted_sampler , weighted_sampler_t contains !> Create a new binary tree sampler with N weights !> Input: n - number of weights function weighted_sampler_new ( n ) result ( this ) type ( weighted_sampler_t ) :: this integer ( i4 ), intent ( in ) :: n call this % init ( n ) end function weighted_sampler_new !> Initializes the structure with N weights !> Input: n - number of weights subroutine sampler_init ( this , n ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n this % n = n allocate ( this % weights ( n )) allocate ( this % tree ( 2 * n - 1 )) ! complete binary tree with n leaves this % weights = 0.0_dp this % tree = 0.0_dp end subroutine sampler_init !> Placeholder for 1D initialization (compat mode), maps to original init !> Input: n - number of weights !>        w - any real number, not used subroutine sampler_init_w ( this , n , w ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w call this % init ( n ) ! call original init end subroutine sampler_init_w !> Placeholder for 1D initialization (compat mode), maps to original init !> Input: n - number of weights !>        w1 - any real number, not used !>        w2 - any real number, not used subroutine sampler_init_w2 ( this , n , w1 , w2 ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w1 , w2 call this % init ( n ) ! call original init end subroutine sampler_init_w2 !> Resets the sampler: clears the list subroutine sampler_reset ( this ) class ( weighted_sampler_t ), intent ( inout ) :: this ! DEBUG !if (this%n <= 0) error stop \"reset: sampler not initialized\" this % weights = 0.0_dp this % tree = 0.0_dp end subroutine sampler_reset !> Sets the weight for a given index !> Input: index - index of the element with a given weight !>        weight - weight of the element subroutine sampler_set_weight ( this , index , weight ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: weight integer ( i4 ) :: i real ( dp ) :: delta ! DEBUG !if (index < 1 .or. index > this%n) error stop 'Index out of bounds in sampler_set_weight' delta = weight - this % weights ( index ) !if (delta == 0.0_dp) return this % weights ( index ) = weight ! we perform a bottom-up update of the tree i = index + this % n - 1 do while ( i >= 1 ) this % tree ( i ) = this % tree ( i ) + delta i = i / 2 end do end subroutine sampler_set_weight !> Sets the weights from an array (full), using its indexes !> Weights should be larger than zero !> It assumes it was initialized before, and has the same size !> Input: weights - array with the weights subroutine sampler_set_weight_array ( this , weights ) class ( weighted_sampler_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: weights (:) integer ( i4 ) :: i ! DEBUG !if (size(weights) /= this%n) error stop 'Weights array size does not match sampler size' ! Copy the weights this % weights = weights ! Define the weights do i = 1 , this % n this % tree ( i + this % n - 1 ) = weights ( i ) end do ! Perform a bottom-up update of the tree do i = this % n - 1 , 1 , - 1 this % tree ( i ) = this % tree ( 2 * i ) + this % tree ( 2 * i + 1 ) end do end subroutine sampler_set_weight_array !> Adds a weight to the sampler at a given index !> Input: index - index of the element !>        delta_weight - difference to add to its weight subroutine sampler_add_weight ( this , index , delta_weight ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: delta_weight ! DEBUG !if (index < 1 .or. index > this%n) error stop 'Index out of bounds in sampler_add_weight' call this % set_weight ( index , this % weights ( index ) + delta_weight ) ! call set_weight for each weight end subroutine sampler_add_weight !> Remove an index from the sampler !> Important: the index is the original one, not the index used internally by the sampler !> Input: index - index of the element to be removed subroutine sampler_remove ( this , index ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index ! DEBUG !if (index < 1 .or. index > this%n) error stop 'Index out of bounds in sampler_remove' call this % set_weight ( index , 0.0_dp ) ! we just update weight to zero end subroutine sampler_remove !> Samples an index from the sampler !> Input: gen - random number generator (rndgen-fortran module) !> Output: index - sampled index function sampler_sample ( this , gen ) result ( index ) use rndgen_mod class ( weighted_sampler_t ), intent ( in ) :: this class ( rndgen ), intent ( inout ) :: gen integer ( i4 ) :: index real ( dp ) :: r integer ( i4 ) :: i ! DEBUG ! if (this%tree(1) <= 0.0_dp) error stop \"sample: total weight is zero\" ! for that, we calculate a random value from the top (sum of weights) r = gen % rnd () * this % tree ( 1 ) ! we start to go down, performing a binary search i = 1 do while ( i < this % n ) if ( r <= this % tree ( 2 * i )) then i = 2 * i else r = r - this % tree ( 2 * i ) i = 2 * i + 1 end if end do index = i - this % n + 1 end function sampler_sample !> Get the sum of all weights !> Output: total - sum of all weights function sampler_sum ( this ) result ( total ) class ( weighted_sampler_t ), intent ( in ) :: this real ( dp ) :: total ! DEBUG !if (this%n <= 0) error stop \"sum: sampler not initialized\" total = this % tree ( 1 ) ! the root contains the total sum end function sampler_sum !> Finalize the sampler, deallocate resources subroutine sampler_finalize ( this ) type ( weighted_sampler_t ), intent ( inout ) :: this if ( allocated ( this % weights )) deallocate ( this % weights ) if ( allocated ( this % tree )) deallocate ( this % tree ) this % n = 0 end subroutine sampler_finalize end module samplers_btree_mod","tags":"","url":"sourcefile/btree.f90.html"},{"title":"rejection_maxheap.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~rejection_maxheap.f90~~EfferentGraph sourcefile~rejection_maxheap.f90 rejection_maxheap.f90 sourcefile~base.f90 base.f90 sourcefile~rejection_maxheap.f90->sourcefile~base.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~rejection_maxheap.f90->sourcefile~kinds.f90 sourcefile~lists.f90 lists.f90 sourcefile~rejection_maxheap.f90->sourcefile~lists.f90 sourcefile~base.f90->sourcefile~kinds.f90 sourcefile~lists.f90->sourcefile~kinds.f90 sourcefile~dynamical_list.f90 dynamical_list.f90 sourcefile~lists.f90->sourcefile~dynamical_list.f90 sourcefile~fixed_list.f90 fixed_list.f90 sourcefile~lists.f90->sourcefile~fixed_list.f90 sourcefile~maxheap.f90 maxheap.f90 sourcefile~lists.f90->sourcefile~maxheap.f90 sourcefile~dynamical_list.f90->sourcefile~kinds.f90 sourcefile~fixed_list.f90->sourcefile~kinds.f90 sourcefile~maxheap.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~rejection_maxheap.f90~~AfferentGraph sourcefile~rejection_maxheap.f90 rejection_maxheap.f90 sourcefile~rejection_maxheap_composition.f90 rejection_maxheap_composition.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_maxheap_two_classes.f90 rejection_maxheap_two_classes.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~rejection_maxheap.f90 sourcefile~samplers.f90 samplers.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_composition.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_two_classes.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module samplers_rejection_maxheap_mod use kinds_mod use lists_mod use samplers_base_mod implicit none private real ( kind = dp ), parameter :: EPSILON = 0.0_dp !> Constructor interface weighted_sampler module procedure weighted_sampler_new end interface weighted_sampler !> Derived type, extending from the base type , extends ( sampler_base_t ) :: weighted_sampler_t type ( dynamical_list_t ), allocatable :: indices type ( maxheap_t ), allocatable :: heap ! max-heap for efficient sampling integer ( i4 ), allocatable :: position_of (:) ! index positions real ( kind = dp ) :: current_sum = 0.0_dp ! current sum of the weights contains procedure :: init_n => sampler_init procedure :: init_w => sampler_init_w procedure :: init_w2 => sampler_init_w2 procedure :: reset => sampler_reset procedure :: set_weight => sampler_set_weight procedure :: set_weight_array => sampler_set_weight_array procedure :: add_weight => sampler_add_weight procedure :: sample => sampler_sample procedure :: remove => sampler_remove procedure :: sum => sampler_sum final :: sampler_finalize end type weighted_sampler_t public :: weighted_sampler , weighted_sampler_t contains !> Create a new rejection sampler with N weights !> Input: n - number of weights function weighted_sampler_new ( n ) result ( this ) type ( weighted_sampler_t ) :: this integer ( i4 ), intent ( in ) :: n call this % init ( n ) end function weighted_sampler_new !> Initializes the structure with N weights !> Input: n - number of weights subroutine sampler_init ( this , n ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n this % n = n allocate ( this % weights ( n )) allocate ( this % indices ) allocate ( this % position_of ( n )) call this % indices % init ( n ) this % position_of = 0 this % current_sum = 0.0_dp this % heap = maxheap ( n ) ! Initialize the max-heap with size n this % weights = 0.0_dp ! Initialize weights to zero end subroutine sampler_init !> Placeholder for 1D initialization (compat mode), maps to original init !> Input: n - number of weights !>        w - any real number, not used subroutine sampler_init_w ( this , n , w ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w call this % init ( n ) ! call original init end subroutine sampler_init_w !> Placeholder for 1D initialization (compat mode), maps to original init !> Input: n - number of weights !>        w1 - any real number, not used !>        w2 - any real number, not used subroutine sampler_init_w2 ( this , n , w1 , w2 ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w1 , w2 call this % init ( n ) ! call original init end subroutine sampler_init_w2 !> Resets the sampler: clears the list subroutine sampler_reset ( this ) class ( weighted_sampler_t ), intent ( inout ) :: this call this % indices % reset () this % position_of = 0 this % current_sum = 0.0_dp this % weights = 0.0_dp deallocate ( this % heap ) this % heap = maxheap ( this % n ) ! Reinitialize the max-heap with size n end subroutine sampler_reset !> Sets the weight for a given index !> Input: index - index of the element with a given weight !>        weight - weight of the element subroutine sampler_set_weight ( this , index , weight ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: weight ! DEBUG !if (index < 1 .or. index > this%n) error stop 'Index out of bounds in sampler_set_weight' ! if the weight is zero, remove the index from the list if ( weight <= EPSILON ) then call this % remove ( index ) return end if ! check if the index is already added to the list if ( this % position_of ( index ) /= 0 ) then ! remove the current sum this % current_sum = this % current_sum - this % weights ( index ) call this % heap % remove ( index ) else call this % indices % add ( index ) this % position_of ( index ) = this % indices % n_used end if ! sets the weight this % weights ( index ) = weight ! update the current sum this % current_sum = this % current_sum + weight ! we do not remove the last weight since it is a new one ! update the maximum weight call this % heap % add ( weight , index ) ! Add to the max-heap end subroutine sampler_set_weight !> Sets the weights from an array (full), using its indexes !> Weights should be larger than zero !> It assumes it was initialized before, and has the same size !> Input: weights - array with the weights subroutine sampler_set_weight_array ( this , weights ) class ( weighted_sampler_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: weights (:) integer ( i4 ) :: i ! DEBUG !if (size(weights) /= this%n) error stop 'Weights array size does not match sampler size' this % weights = weights call this % indices % reset () ! Reset the indices list this % current_sum = 0.0_dp do i = 1 , this % n call this % indices % add ( i ) call this % heap % add ( weights ( i ), i ) ! Add to the max-heap this % position_of ( i ) = this % indices % n_used this % current_sum = this % current_sum + weights ( i ) end do end subroutine sampler_set_weight_array !> Adds a weight to the sampler at a given index !> Input: index - index of the element !>        delta_weight - difference to add to its weight subroutine sampler_add_weight ( this , index , delta_weight ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: delta_weight ! DEBUG !if (index < 1 .or. index > this%n) error stop 'Index out of bounds in sampler_add_weight' call this % set_weight ( index , this % weights ( index ) + delta_weight ) end subroutine sampler_add_weight !> Remove an index from the sampler !> Important: the index is the original one, not the index used internally by the sampler !> Input: index - index of the element to be removed subroutine sampler_remove ( this , index ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index integer ( i4 ) :: pos ! DEBUG !if (index < 1 .or. index > this%n) error stop 'Index out of bounds in sampler_remove' pos = this % position_of ( index ) if ( pos /= 0 ) then ! Update the current sum this % current_sum = this % current_sum - this % weights ( index ) ! Update the position_of the last element of the list this % position_of ( this % indices % list ( this % indices % n_used )) = pos ! Remove the weight from the list call this % indices % remove ( pos ) this % position_of ( index ) = 0 ! Mark as removed this % weights ( index ) = 0.0_dp ! Set the weight to zero call this % heap % remove ( index ) ! Remove from the max-heap end if end subroutine sampler_remove !> Samples an index from the sampler !> Input: gen - random number generator (rndgen-fortran module) !> Output: index - sampled index function sampler_sample ( this , gen ) result ( index ) use rndgen_mod class ( weighted_sampler_t ), intent ( in ) :: this class ( rndgen ), intent ( inout ) :: gen integer ( i4 ) :: index , index_pos real ( dp ) :: weight ! We will use rejection sampling to select an index do ! Select a random index from the list of indices index_pos = gen % int ( 1 , this % indices % n_used ) index = this % indices % list ( index_pos ) weight = this % weights ( index ) ! Check if the rate is sufficient to accept this index if ( gen % rnd () < weight / this % heap % max_value ()) return ! else, we reject and try again end do end function !> Get the sum of all weights !> Output: total - sum of all weights function sampler_sum ( this ) result ( total_weight ) class ( weighted_sampler_t ), intent ( in ) :: this real ( dp ) :: total_weight total_weight = this % current_sum end function sampler_sum !> Finalize the sampler, deallocate resources subroutine sampler_finalize ( this ) type ( weighted_sampler_t ), intent ( inout ) :: this if ( allocated ( this % indices )) then deallocate ( this % indices ) end if if ( allocated ( this % weights )) then deallocate ( this % weights ) end if if ( allocated ( this % position_of )) then deallocate ( this % position_of ) end if end subroutine sampler_finalize end module samplers_rejection_maxheap_mod","tags":"","url":"sourcefile/rejection_maxheap.f90.html"},{"title":"base.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~base.f90~~EfferentGraph sourcefile~base.f90 base.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~base.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~base.f90~~AfferentGraph sourcefile~base.f90 base.f90 sourcefile~btree.f90 btree.f90 sourcefile~btree.f90->sourcefile~base.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~base.f90 sourcefile~samplers.f90 samplers.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 sourcefile~rejection.f90 rejection.f90 sourcefile~rejection.f90->sourcefile~base.f90 sourcefile~rejection_maxheap.f90 rejection_maxheap.f90 sourcefile~rejection_maxheap.f90->sourcefile~base.f90 sourcefile~rejection_maxheap_composition.f90 rejection_maxheap_composition.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~base.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~btree.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_maxheap_two_classes.f90 rejection_maxheap_two_classes.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~base.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_two_classes.f90 rejection_two_classes.f90 sourcefile~rejection_two_classes.f90->sourcefile~base.f90 sourcefile~rejection_two_classes.f90->sourcefile~rejection.f90 sourcefile~samplers.f90->sourcefile~base.f90 sourcefile~samplers.f90->sourcefile~btree.f90 sourcefile~samplers.f90->sourcefile~rejection.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_composition.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_two_classes.f90 sourcefile~samplers.f90->sourcefile~rejection_two_classes.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> This module implements the basic structure for weighted samplers module samplers_base_mod use kinds_mod implicit none private !> Base type for all samplers type , abstract :: sampler_base_t real ( dp ), allocatable :: weights (:) ! individual weights integer ( i4 ) :: n = 0 ! number of weights contains procedure ( i_init_n ), deferred :: init_n ! Initializes with a fixed number of weights procedure ( i_init_w ), deferred :: init_w ! Initializes with one additional argument procedure ( i_init_w2 ), deferred :: init_w2 ! Initializes with two additional arguments generic :: init => init_n , init_w , init_w2 ! Generic initialization procedure ( i_reset ), deferred :: reset ! Resets the sampler procedure ( i_set_weight ), deferred :: set_weight ! Sets the weight for a specific index procedure ( i_set_weight_array ), deferred :: set_weight_array ! Sets the weights for all indices procedure ( i_add_weight ), deferred :: add_weight ! Adds weight to a specific index procedure ( i_sample ), deferred :: sample ! Returns an index proportional to its weight procedure ( i_remove ), deferred :: remove ! Removes a specific index procedure ( i_sum ), deferred :: sum ! Returns the total weight end type sampler_base_t abstract interface subroutine i_init_n ( this , n ) import :: sampler_base_t , i4 class ( sampler_base_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n end subroutine subroutine i_init_w ( this , n , w ) import :: sampler_base_t , dp , i4 class ( sampler_base_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w end subroutine subroutine i_init_w2 ( this , n , w1 , w2 ) import :: sampler_base_t , dp , i4 class ( sampler_base_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w1 , w2 end subroutine subroutine i_reset ( this ) import :: sampler_base_t class ( sampler_base_t ), intent ( inout ) :: this end subroutine subroutine i_set_weight ( this , index , weight ) import :: sampler_base_t , i4 , dp class ( sampler_base_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: weight end subroutine subroutine i_set_weight_array ( this , weights ) import :: sampler_base_t , dp class ( sampler_base_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: weights (:) end subroutine subroutine i_add_weight ( this , index , delta_weight ) import :: sampler_base_t , i4 , dp class ( sampler_base_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: delta_weight end subroutine function i_sample ( this , gen ) result ( index ) use rndgen_mod , only : rndgen import :: sampler_base_t , i4 class ( sampler_base_t ), intent ( in ) :: this class ( rndgen ), intent ( inout ) :: gen integer ( i4 ) :: index end function subroutine i_remove ( this , index ) import :: sampler_base_t , i4 class ( sampler_base_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index end subroutine function i_sum ( this ) result ( total_weight ) import :: sampler_base_t , dp class ( sampler_base_t ), intent ( in ) :: this real ( dp ) :: total_weight end function end interface public :: sampler_base_t end module samplers_base_mod","tags":"","url":"sourcefile/base.f90.html"},{"title":"kinds.f90 – Data structures for Fortran","text":"Files dependent on this one sourcefile~~kinds.f90~~AfferentGraph sourcefile~kinds.f90 kinds.f90 sourcefile~base.f90 base.f90 sourcefile~base.f90->sourcefile~kinds.f90 sourcefile~btree.f90 btree.f90 sourcefile~btree.f90->sourcefile~kinds.f90 sourcefile~btree.f90->sourcefile~base.f90 sourcefile~dynamical_list.f90 dynamical_list.f90 sourcefile~dynamical_list.f90->sourcefile~kinds.f90 sourcefile~fixed_list.f90 fixed_list.f90 sourcefile~fixed_list.f90->sourcefile~kinds.f90 sourcefile~hash.f90 hash.f90 sourcefile~hash.f90->sourcefile~kinds.f90 sourcefile~lists.f90 lists.f90 sourcefile~lists.f90->sourcefile~kinds.f90 sourcefile~lists.f90->sourcefile~dynamical_list.f90 sourcefile~lists.f90->sourcefile~fixed_list.f90 sourcefile~maxheap.f90 maxheap.f90 sourcefile~lists.f90->sourcefile~maxheap.f90 sourcefile~maxheap.f90->sourcefile~kinds.f90 sourcefile~rejection.f90 rejection.f90 sourcefile~rejection.f90->sourcefile~kinds.f90 sourcefile~rejection.f90->sourcefile~base.f90 sourcefile~rejection.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap.f90 rejection_maxheap.f90 sourcefile~rejection_maxheap.f90->sourcefile~kinds.f90 sourcefile~rejection_maxheap.f90->sourcefile~base.f90 sourcefile~rejection_maxheap.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_composition.f90 rejection_maxheap_composition.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~kinds.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~base.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~btree.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_maxheap_two_classes.f90 rejection_maxheap_two_classes.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~kinds.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~base.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_two_classes.f90 rejection_two_classes.f90 sourcefile~rejection_two_classes.f90->sourcefile~kinds.f90 sourcefile~rejection_two_classes.f90->sourcefile~base.f90 sourcefile~rejection_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_two_classes.f90->sourcefile~rejection.f90 sourcefile~samplers.f90 samplers.f90 sourcefile~samplers.f90->sourcefile~kinds.f90 sourcefile~samplers.f90->sourcefile~base.f90 sourcefile~samplers.f90->sourcefile~btree.f90 sourcefile~samplers.f90->sourcefile~rejection.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_composition.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_two_classes.f90 sourcefile~samplers.f90->sourcefile~rejection_two_classes.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~base.f90 sourcefile~datastructs-fortran.f90->sourcefile~hash.f90 sourcefile~datastructs-fortran.f90->sourcefile~lists.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module kinds_mod use , intrinsic :: iso_fortran_env , only : & sp => real32 , & ! single precision, range: -3.40282347E+38 to 3.40282347E+38, smallest positive: 1.17549435E-38 dp => real64 , & ! double precision, range: -1.7976931348623157E+308 to 1.7976931348623157E+308, smallest positive: 2.2250738585072014E-308 qp => real128 , & i1 => int8 , & ! 1 byte integer, range: -128 to 127 i2 => int16 , & ! 2 byte integer, range: -32768 to 32767 i4 => int32 , & ! 4 byte integer, range: -2147483648 to 2147483647 i8 => int64 ! 8 byte integer, range: -9223372036854775808 to 9223372036854775807 implicit none private !> Interface for the swap subroutine. interface swap module procedure swap_int , swap_real end interface swap character ( len =* ), parameter :: fmt_general = '(*(g0,x))' character ( len =* ), parameter :: fmt_comma = '(*(g0,\",\"))' character ( len =* ), parameter :: fmt_comma_pair = '(g0,\",\",g0)' public :: sp , dp , i1 , i2 , i4 , i8 , list_ranges public :: fmt_general , fmt_comma , choose_fmt_based_on , count_integers_from_string public :: swap contains subroutine swap_int ( a , b ) integer ( kind = i4 ), intent ( inout ) :: a , b integer ( kind = i4 ) :: temp temp = a a = b b = temp end subroutine swap_int subroutine swap_real ( a , b ) real ( kind = dp ), intent ( inout ) :: a , b real ( kind = dp ) :: temp temp = a a = b b = temp end subroutine swap_real subroutine list_ranges () real ( kind = sp ) :: real_sp real ( kind = dp ) :: real_dp real ( kind = qp ) :: real_qp integer ( kind = i1 ) :: int_i1 integer ( kind = i2 ) :: int_i2 integer ( kind = i4 ) :: int_i4 integer ( kind = i8 ) :: int_i8 ! Print the ranges of the types write ( * , * ) \"Single precision range (positive): \" , tiny ( real_sp ), \" to \" , huge ( real_sp ) write ( * , * ) \"Double precision range (positive): \" , tiny ( real_dp ), \" to \" , huge ( real_dp ) write ( * , * ) \"Quadruple precision range (positive): \" , tiny ( real_qp ), \" to \" , huge ( real_qp ) write ( * , * ) \"1 byte integer range: \" , - huge ( int_i1 ) - 1 , \" to \" , huge ( int_i1 ) write ( * , * ) \"2 byte integer range: \" , - huge ( int_i2 ) - 1 , \" to \" , huge ( int_i2 ) write ( * , * ) \"4 byte integer range: \" , - huge ( int_i4 ) - 1 , \" to \" , huge ( int_i4 ) write ( * , * ) \"8 byte integer range: \" , - huge ( int_i8 ) - 1 , \" to \" , huge ( int_i8 ) end subroutine list_ranges function choose_fmt_based_on ( filename ) result ( fmt ) character ( len =* ), intent ( in ) :: filename character ( len = :), allocatable :: fmt character ( len = 4 ), allocatable :: ext if ( len ( filename ) >= 4 ) then ext = filename ( len ( filename ) - 3 : len ( filename )) else ext = '' end if select case ( ext ) case ( '.csv' ) fmt = fmt_comma_pair case ( '.txt' , '.dat' ) fmt = fmt_general case default fmt = fmt_general end select end function choose_fmt_based_on function count_integers_from_string ( str ) result ( count ) character ( len =* ), intent ( in ) :: str integer ( kind = i4 ) :: count integer ( kind = i4 ) :: i , len_str logical :: in_number len_str = len_trim ( str ) count = 0 in_number = . false . do i = 1 , len_str if (( str ( i : i ) == ' ' ) . or . ( str ( i : i ) == ',' )) then if ( in_number ) then count = count + 1 in_number = . false . end if else in_number = . true . end if end do if ( in_number ) count = count + 1 end function count_integers_from_string end module","tags":"","url":"sourcefile/kinds.f90.html"},{"title":"hash.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~hash.f90~~EfferentGraph sourcefile~hash.f90 hash.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~hash.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~hash.f90~~AfferentGraph sourcefile~hash.f90 hash.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~hash.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module hash_mod use kinds_mod implicit none private public :: djb2 contains !> DJB2 hash function !> Inspired by http://www.cse.yorku.ca/~oz/hash.html !> and https://github.com/pdebuyl/fortran_hash_table/blob/master/src/dictionary_m.f90 function djb2 ( list ) result ( r ) integer ( kind = i4 ), intent ( in ) :: list (:) integer ( kind = i8 ) :: r integer ( kind = i4 ) :: i , l l = size ( list ) r = 5381_i8 do i = 1 , l r = ( ishft ( r , 5 ) + r ) + int ( list ( i ), i8 ) end do end function djb2 end module hash_mod","tags":"","url":"sourcefile/hash.f90.html"},{"title":"maxheap.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~maxheap.f90~~EfferentGraph sourcefile~maxheap.f90 maxheap.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~maxheap.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~maxheap.f90~~AfferentGraph sourcefile~maxheap.f90 maxheap.f90 sourcefile~lists.f90 lists.f90 sourcefile~lists.f90->sourcefile~maxheap.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~lists.f90 sourcefile~samplers.f90 samplers.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 sourcefile~rejection.f90 rejection.f90 sourcefile~rejection.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap.f90 rejection_maxheap.f90 sourcefile~rejection_maxheap.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_composition.f90 rejection_maxheap_composition.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_maxheap_two_classes.f90 rejection_maxheap_two_classes.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_two_classes.f90 rejection_two_classes.f90 sourcefile~rejection_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_two_classes.f90->sourcefile~rejection.f90 sourcefile~samplers.f90->sourcefile~rejection.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_composition.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_two_classes.f90 sourcefile~samplers.f90->sourcefile~rejection_two_classes.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> This module implements a maxheap structure, keeping track of the maximum value and its index. !> Example: !> ```fortran !> program example_maxheap !>     use datastructs_fortran !>     use kinds_mod !>     implicit none !>     type(maxheap_t) :: my_heap !>     real(kind=dp), parameter :: list(*) = [40.0_dp,25.5_dp,30.1_dp,100.4_dp,2.0_dp] !>     integer(kind=i4) :: i !> !>     call my_heap%init(10) !> !>     do i = 1, size(list) !>         call my_heap%add(list(i), i) !>     end do !> !>     call my_heap%print() !> !>     call my_heap%remove(4) !> !>     call my_heap%print() !> end program example_maxheap !> ``` module maxheap_mod use kinds_mod implicit none private !> Constructor for a maxheap interface maxheap module procedure maxheap_new end interface maxheap !> Type for a maxheap type :: maxheap_t real ( dp ), allocatable :: values (:) ! heap of values integer ( i4 ), allocatable :: indices (:) ! their corresponding external indices integer ( i4 ), allocatable :: pos_of (:) ! map: index -> position in heap (0 if not present) integer ( i4 ) :: n = 0 ! current heap size integer ( i4 ) :: max_n ! max capacity contains procedure :: init => maxheap_init ! initialize the maxheap procedure :: add => maxheap_add ! adds a new value to the heap procedure :: remove => maxheap_remove ! removes a value from the heap procedure :: add_weight => maxheap_add_weight ! adds a delta weight to an existing index procedure :: print => maxheap_print ! print the maxheap procedure :: max_value => maxheap_max_value ! returns the max value procedure :: max_index => maxheap_max_index ! returns the index of the max value final :: maxheap_finalize ! finalize the maxheap end type public :: maxheap , maxheap_t contains !> Create a new maxheap !> Input: max_size - maximum number of elements in the heap function maxheap_new ( max_size ) result ( this ) type ( maxheap_t ) :: this integer ( kind = i4 ) :: max_size call this % init ( max_size ) end function maxheap_new !> Initialize an empty maxheap !> Input: max_size - maximum number of elements in the heap subroutine maxheap_init ( this , max_size ) class ( maxheap_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: max_size this % max_n = max_size this % n = 0 allocate ( this % values ( max_size )) allocate ( this % indices ( max_size )) allocate ( this % pos_of ( max_size )) this % pos_of = 0 end subroutine maxheap_init !> Adds a new value to the maxheap, with a corresponding index !> Input: value - the value to add !>        index - the corresponding index of the value subroutine maxheap_add ( this , value , index ) class ( maxheap_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: value integer ( i4 ), intent ( in ) :: index integer ( i4 ) :: pos , parent if ( this % n >= this % max_n ) error stop \"Heap full\" if ( index < 1 . or . index > this % max_n ) error stop \"Index out of bounds\" if ( this % pos_of ( index ) /= 0 ) error stop \"Index already in heap\" this % n = this % n + 1 pos = this % n this % values ( pos ) = value this % indices ( pos ) = index this % pos_of ( index ) = pos ! bubble up do while ( pos > 1 ) parent = pos / 2 if ( this % values ( parent ) >= this % values ( pos )) exit call swap ( this % values ( parent ), this % values ( pos )) call swap ( this % indices ( parent ), this % indices ( pos )) this % pos_of ( this % indices ( parent )) = parent this % pos_of ( this % indices ( pos )) = pos pos = parent end do end subroutine maxheap_add !> Adds a delta weight to an existing index !> Input: delta_weight - the weight to add !>        index - the corresponding index of the value subroutine maxheap_add_weight ( this , delta_weight , index ) class ( maxheap_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: delta_weight integer ( i4 ), intent ( in ) :: index real ( dp ) :: weight weight = this % values ( this % pos_of ( index )) + delta_weight ! first we remove it call this % remove ( index ) ! then we add the new weight call this % add ( weight , index ) end subroutine maxheap_add_weight !> Removes a value from the maxheap !> Input: index - the corresponding index of the value subroutine maxheap_remove ( this , index ) class ( maxheap_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index integer ( i4 ) :: pos , last_index , left , right , largest if ( index < 1 . or . index > this % max_n ) return pos = this % pos_of ( index ) if ( pos == 0 ) return ! not in heap, no problem last_index = this % indices ( this % n ) this % values ( pos ) = this % values ( this % n ) this % indices ( pos ) = last_index this % pos_of ( last_index ) = pos this % pos_of ( index ) = 0 this % n = this % n - 1 ! heapify down do left = 2 * pos right = 2 * pos + 1 largest = pos if ( left <= this % n ) then if ( this % values ( left ) > this % values ( largest )) largest = left end if if ( right <= this % n ) then if ( this % values ( right ) > this % values ( largest )) largest = right end if if ( largest == pos ) exit call swap ( this % values ( pos ), this % values ( largest )) call swap ( this % indices ( pos ), this % indices ( largest )) this % pos_of ( this % indices ( pos )) = pos this % pos_of ( this % indices ( largest )) = largest pos = largest end do end subroutine maxheap_remove !> Gets the maximum value from the maxheap function maxheap_max_value ( this ) result ( value ) class ( maxheap_t ), intent ( in ) :: this real ( dp ) :: value if ( this % n > 0 ) then value = this % values ( 1 ) else write ( * , fmt_general ) \"Heap is empty\" value = - huge ( value ) end if end function maxheap_max_value !> Gets the original index of the maximum value function maxheap_max_index ( this ) result ( index ) class ( maxheap_t ), intent ( in ) :: this integer ( i4 ) :: index if ( this % n > 0 ) then index = this % indices ( 1 ) else write ( * , fmt_general ) \"Heap is empty\" index = - 1 ! or some other invalid value end if end function maxheap_max_index !> Prints the contents of the maxheap subroutine maxheap_print ( this ) class ( maxheap_t ), intent ( in ) :: this if ( this % n > 0 ) then write ( * , fmt_general ) \"Max value and corresponding index:\" , this % values ( 1 ), this % indices ( 1 ) else write ( * , fmt_general ) \"Heap is empty\" end if end subroutine maxheap_print !> Finalizes the maxheap subroutine maxheap_finalize ( this ) type ( maxheap_t ), intent ( inout ) :: this if ( allocated ( this % values )) deallocate ( this % values ) if ( allocated ( this % indices )) deallocate ( this % indices ) if ( allocated ( this % pos_of )) deallocate ( this % pos_of ) end subroutine maxheap_finalize end module maxheap_mod","tags":"","url":"sourcefile/maxheap.f90.html"},{"title":"dynamical_list.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~dynamical_list.f90~~EfferentGraph sourcefile~dynamical_list.f90 dynamical_list.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~dynamical_list.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~dynamical_list.f90~~AfferentGraph sourcefile~dynamical_list.f90 dynamical_list.f90 sourcefile~lists.f90 lists.f90 sourcefile~lists.f90->sourcefile~dynamical_list.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~lists.f90 sourcefile~samplers.f90 samplers.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 sourcefile~rejection.f90 rejection.f90 sourcefile~rejection.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap.f90 rejection_maxheap.f90 sourcefile~rejection_maxheap.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_composition.f90 rejection_maxheap_composition.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_maxheap_two_classes.f90 rejection_maxheap_two_classes.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_two_classes.f90 rejection_two_classes.f90 sourcefile~rejection_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_two_classes.f90->sourcefile~rejection.f90 sourcefile~samplers.f90->sourcefile~rejection.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_composition.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_two_classes.f90 sourcefile~samplers.f90->sourcefile~rejection_two_classes.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> This module implements a dynamical list, in which elements can be added or removed dynamically. !> It assumes that there is a maximum size, and elements can be added or removed up to that size. !> Example: !> ```fortran !> program test_dynamical_list !>     use datastructs_fortran !>     use kinds_mod !>     implicit none !>     type(dynamical_list_t) :: my_list !>     integer(kind=i4) :: i !>     call my_list%init(10) !>     do i = 1, 10 !>         call my_list%add(i) !>     end do !>     call my_list%print() !>     call my_list%remove(5) !>     call my_list%print() !> end program test_dynamical_list !> ``` module lists_dynamical_list_mod use kinds_mod implicit none private !> Constructor for a dynamical list interface dynamical_list module procedure dynamical_list_new end interface dynamical_list !> List of integers with a given maximum fixed size !> The first index is always 1, and filled up to n_used !> It contains routines for managing the list type :: dynamical_list_t integer ( kind = i4 ) :: n = 0 integer ( kind = i4 ) :: n_used = 0 integer ( kind = i4 ), allocatable :: list (:) contains procedure :: init => dynamical_list_init ! initialize the list procedure :: reset => dynamical_list_reset ! reset the list procedure :: print => dynamical_list_print ! print the list procedure :: expand => dynamical_list_expand ! expand the list to a new size procedure :: trim => dynamical_list_trim ! trim the list to n_used procedure :: last => dynamical_list_last ! get the last element procedure :: count => dynamical_list_count ! count the number of times an element appears in the list procedure , private :: dynamical_list_create_from_array procedure , private :: dynamical_list_add_element , dynamical_list_add_array procedure , private :: dynamical_list_remove_position , dynamical_list_remove_position_array , & dynamical_list_remove_position_range generic :: add => dynamical_list_add_element , dynamical_list_add_array ! add elements generic :: remove => dynamical_list_remove_position , dynamical_list_remove_position_array , & dynamical_list_remove_position_range ! remove indexes generic :: assignment ( = ) => dynamical_list_create_from_array ! create from array procedure :: get => dynamical_list_get ! get element at position procedure :: sum => dynamical_list_sum ! sum the elements final :: finalize_dynamical_list ! finalize the list end type dynamical_list_t public :: dynamical_list , dynamical_list_t contains !> Create a new dynamical list !> Input: list - an array of integers !> Output: a new dynamical list function dynamical_list_new ( list ) result ( this ) type ( dynamical_list_t ) :: this integer ( kind = i4 ), intent ( in ) :: list (:) ! allocate the dynamical list this % n = size ( list ) ! since we start with a full list, we set n_used to n this % n_used = size ( list ) ! copy the elements to the list this % list = list end function dynamical_list_new !> Finalize the list !> For that, we need to deallocate the list subroutine finalize_dynamical_list ( this ) type ( dynamical_list_t ), intent ( inout ) :: this if ( allocated ( this % list )) deallocate ( this % list ) end subroutine finalize_dynamical_list !> Initialize an empty list with a given size !> Input: n - the size of the list subroutine dynamical_list_init ( this , n ) class ( dynamical_list_t ), intent ( inout ) :: this integer ( kind = i4 ), intent ( in ) :: n this % n = n this % n_used = 0 allocate ( this % list ( n )) end subroutine dynamical_list_init !> Reset the list !> For that, we only need to set n_used to 0 subroutine dynamical_list_reset ( this ) class ( dynamical_list_t ), intent ( inout ) :: this this % n_used = 0 end subroutine dynamical_list_reset !> Trim the list to the number of used elements subroutine dynamical_list_trim ( this ) class ( dynamical_list_t ), intent ( inout ) :: this integer ( kind = i4 ), allocatable :: new_list (:) new_list = this % list ( 1 : this % n_used ) call move_alloc ( new_list , this % list ) this % n = this % n_used end subroutine dynamical_list_trim !> Expand the list to a new size subroutine dynamical_list_expand ( this , new_size ) class ( dynamical_list_t ), intent ( inout ) :: this integer ( kind = i4 ), intent ( in ) :: new_size integer ( kind = i4 ), allocatable :: new_list (:) if ( new_size <= this % n ) then stop 'Error: new size must be greater than current size' end if allocate ( new_list ( new_size )) new_list ( 1 : this % n_used ) = this % list ( 1 : this % n_used ) call move_alloc ( new_list , this % list ) this % n = new_size end subroutine dynamical_list_expand !> Return the sum of the elements in the list !> It sums only the valid elements function dynamical_list_sum ( this ) result ( val ) class ( dynamical_list_t ), intent ( in ) :: this integer ( kind = i4 ) :: val val = sum ( this % list ( 1 : this % n_used )) end function dynamical_list_sum !> Returns the element at the given position !> Input: position - the position of the element to return function dynamical_list_get ( this , position ) result ( val ) class ( dynamical_list_t ), intent ( in ) :: this integer ( kind = i4 ), intent ( in ) :: position integer ( kind = i4 ) :: val val = this % list ( position ) end function dynamical_list_get !> Returns the last element of the list function dynamical_list_last ( this ) result ( val ) class ( dynamical_list_t ), intent ( in ) :: this integer ( kind = i4 ) :: val val = dynamical_list_get ( this , this % n_used ) end function dynamical_list_last !> Count the number of times an element appears in the list function dynamical_list_count ( this , element ) result ( cnt ) class ( dynamical_list_t ), intent ( in ) :: this integer ( kind = i4 ), intent ( in ) :: element integer ( kind = i4 ) :: cnt cnt = count ( this % list ( 1 : this % n_used ) == element ) end function dynamical_list_count !> Add an element to the list !> It assumes that the list is already allocated !> The element is added to the end of the list !> Input: element - the element to add subroutine dynamical_list_add_element ( this , element ) class ( dynamical_list_t ), intent ( inout ) :: this integer ( kind = i4 ), intent ( in ) :: element this % n_used = this % n_used + 1 this % list ( this % n_used ) = element end subroutine dynamical_list_add_element !> Add an array to the list !> It will initialize the list if it is not already allocated, with the size of the array !> Input: array - the array to add subroutine dynamical_list_add_array ( this , array ) class ( dynamical_list_t ), intent ( inout ) :: this integer ( kind = i4 ), intent ( in ) :: array (:) ! add the new array to the end of the list this % list ( this % n_used + 1 : this % n_used + size ( array )) = array ! add the size of the array to the number of used elements this % n_used = this % n_used + size ( array ) end subroutine dynamical_list_add_array !> Create from array, if it is not already allocated !> Input: array - the array to create the list from subroutine dynamical_list_create_from_array ( this , array ) class ( dynamical_list_t ), intent ( inout ) :: this integer ( kind = i4 ), intent ( in ) :: array (:) if (. not . allocated ( this % list )) then call this % init ( size ( array )) call dynamical_list_add_array ( this , array ) else stop 'Error: list already allocated' end if end subroutine dynamical_list_create_from_array !> Remove an element from the list !> It will replace the element at the given position with the last element !> WARNING: This can change the position of the elements in the list, DO NOT use sequentially !>  with the original indexes, that are not updated after each removal !> Input: position - the position of the element to remove subroutine dynamical_list_remove_position ( this , position ) class ( dynamical_list_t ), intent ( inout ) :: this integer ( kind = i4 ), intent ( in ) :: position ! replace the element at position with the last element this % list ( position ) = this % list ( this % n_used ) ! decrease the number of used elements this % n_used = this % n_used - 1 end subroutine dynamical_list_remove_position !> Remove a range of elements from the list !> It will replace the elements in the range with the last elements !> This is safe because the elements are removed in reverse order !> Input: ini_position - the initial position of the range to remove !>        fin_position - the final position of the range to remove subroutine dynamical_list_remove_position_range ( this , ini_position , fin_position ) class ( dynamical_list_t ), intent ( inout ) :: this integer ( kind = i4 ), intent ( in ) :: ini_position , fin_position integer ( kind = i4 ) :: position_idx do position_idx = fin_position , ini_position , - 1 call dynamical_list_remove_position ( this , position_idx ) end do end subroutine dynamical_list_remove_position_range !> Remove a list of elements from the list !> It will replace the elements in the list with the last elements !> For that, we need to sort the positions !> It is safe because the elements are removed in reverse order !> Input: position_arr - the array of positions to remove !> Dependency: stdlib_sorting subroutine dynamical_list_remove_position_array ( this , position_arr ) use stdlib_sorting , only : sort class ( dynamical_list_t ), intent ( inout ) :: this integer ( kind = i4 ), intent ( in ) :: position_arr (:) integer ( kind = i4 ), allocatable :: sorted_position_arr (:) integer ( kind = i4 ) :: position_idx ! First, we need to sort the positions in descending order ! This is necessary to avoid changing the positions of the elements that are not yet removed sorted_position_arr = position_arr call sort ( sorted_position_arr , reverse = . true .) do position_idx = 1 , size ( sorted_position_arr ) call dynamical_list_remove_position ( this , sorted_position_arr ( position_idx )) end do end subroutine dynamical_list_remove_position_array !> Print the list subroutine dynamical_list_print ( this ) class ( dynamical_list_t ), intent ( in ) :: this write ( * , fmt_general ) '(n = ' , this % n , ', n_used = ' , this % n_used , ')' , this % list ( 1 : this % n_used ) end subroutine dynamical_list_print end module lists_dynamical_list_mod","tags":"","url":"sourcefile/dynamical_list.f90.html"},{"title":"datastructs-fortran.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~datastructs-fortran.f90~~EfferentGraph sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~base.f90 base.f90 sourcefile~datastructs-fortran.f90->sourcefile~base.f90 sourcefile~hash.f90 hash.f90 sourcefile~datastructs-fortran.f90->sourcefile~hash.f90 sourcefile~lists.f90 lists.f90 sourcefile~datastructs-fortran.f90->sourcefile~lists.f90 sourcefile~samplers.f90 samplers.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~base.f90->sourcefile~kinds.f90 sourcefile~hash.f90->sourcefile~kinds.f90 sourcefile~dynamical_list.f90 dynamical_list.f90 sourcefile~lists.f90->sourcefile~dynamical_list.f90 sourcefile~fixed_list.f90 fixed_list.f90 sourcefile~lists.f90->sourcefile~fixed_list.f90 sourcefile~lists.f90->sourcefile~kinds.f90 sourcefile~maxheap.f90 maxheap.f90 sourcefile~lists.f90->sourcefile~maxheap.f90 sourcefile~samplers.f90->sourcefile~base.f90 sourcefile~btree.f90 btree.f90 sourcefile~samplers.f90->sourcefile~btree.f90 sourcefile~samplers.f90->sourcefile~kinds.f90 sourcefile~rejection.f90 rejection.f90 sourcefile~samplers.f90->sourcefile~rejection.f90 sourcefile~rejection_maxheap.f90 rejection_maxheap.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_maxheap_composition.f90 rejection_maxheap_composition.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_composition.f90 sourcefile~rejection_maxheap_two_classes.f90 rejection_maxheap_two_classes.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_two_classes.f90 sourcefile~rejection_two_classes.f90 rejection_two_classes.f90 sourcefile~samplers.f90->sourcefile~rejection_two_classes.f90 sourcefile~btree.f90->sourcefile~base.f90 sourcefile~btree.f90->sourcefile~kinds.f90 sourcefile~dynamical_list.f90->sourcefile~kinds.f90 sourcefile~fixed_list.f90->sourcefile~kinds.f90 sourcefile~maxheap.f90->sourcefile~kinds.f90 sourcefile~rejection.f90->sourcefile~base.f90 sourcefile~rejection.f90->sourcefile~lists.f90 sourcefile~rejection.f90->sourcefile~kinds.f90 sourcefile~rejection_maxheap.f90->sourcefile~base.f90 sourcefile~rejection_maxheap.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap.f90->sourcefile~kinds.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~base.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~btree.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~kinds.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~base.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~kinds.f90 sourcefile~rejection_maxheap_two_classes.f90->sourcefile~rejection_maxheap.f90 sourcefile~rejection_two_classes.f90->sourcefile~base.f90 sourcefile~rejection_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection_two_classes.f90->sourcefile~kinds.f90 sourcefile~rejection_two_classes.f90->sourcefile~rejection.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module datastructs_fortran use hash_mod , only : djb2 use lists_mod , only : dynamical_list , fixed_list , maxheap , & dynamical_list_t , fixed_list_t , maxheap_t , & unique_values , new_fixed_list_pointer use samplers_base_mod , only : sampler_base_t use samplers_mod , only : choose_sampler implicit none private !> Hash functions public :: djb2 !> Lists and maxheap constructors public :: dynamical_list , fixed_list , maxheap !> Derived types for lists and maxheap public :: dynamical_list_t , fixed_list_t , maxheap_t !> Utility functions for lists and maxheap public :: unique_values , new_fixed_list_pointer !> Base type for all samplers public :: sampler_base_t !> Choose a sampler based on the selected algorithm public :: choose_sampler end module datastructs_fortran","tags":"","url":"sourcefile/datastructs-fortran.f90.html"},{"title":"rejection_maxheap_composition.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~rejection_maxheap_composition.f90~~EfferentGraph sourcefile~rejection_maxheap_composition.f90 rejection_maxheap_composition.f90 sourcefile~base.f90 base.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~base.f90 sourcefile~btree.f90 btree.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~btree.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~kinds.f90 sourcefile~lists.f90 lists.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~lists.f90 sourcefile~rejection_maxheap.f90 rejection_maxheap.f90 sourcefile~rejection_maxheap_composition.f90->sourcefile~rejection_maxheap.f90 sourcefile~base.f90->sourcefile~kinds.f90 sourcefile~btree.f90->sourcefile~base.f90 sourcefile~btree.f90->sourcefile~kinds.f90 sourcefile~lists.f90->sourcefile~kinds.f90 sourcefile~dynamical_list.f90 dynamical_list.f90 sourcefile~lists.f90->sourcefile~dynamical_list.f90 sourcefile~fixed_list.f90 fixed_list.f90 sourcefile~lists.f90->sourcefile~fixed_list.f90 sourcefile~maxheap.f90 maxheap.f90 sourcefile~lists.f90->sourcefile~maxheap.f90 sourcefile~rejection_maxheap.f90->sourcefile~base.f90 sourcefile~rejection_maxheap.f90->sourcefile~kinds.f90 sourcefile~rejection_maxheap.f90->sourcefile~lists.f90 sourcefile~dynamical_list.f90->sourcefile~kinds.f90 sourcefile~fixed_list.f90->sourcefile~kinds.f90 sourcefile~maxheap.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~rejection_maxheap_composition.f90~~AfferentGraph sourcefile~rejection_maxheap_composition.f90 rejection_maxheap_composition.f90 sourcefile~samplers.f90 samplers.f90 sourcefile~samplers.f90->sourcefile~rejection_maxheap_composition.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> This module implements a rejection composition sampler !> It is based on \"St-Onge, G., Young, J. G., Hébert-Dufresne, L., & Dubé, L. J. (2019). !> Efficient sampling of spreading processes on complex networks using a composition and rejection algorithm. !> Computer physics communications, 240, 30-37\" !> <https://doi.org/10.1016/j.cpc.2019.02.008> module samplers_rejection_maxheap_composition_mod use kinds_mod use lists_mod use samplers_rejection_maxheap_mod , only : rejection_maxheap_t => weighted_sampler_t use samplers_btree_mod , only : btree_t => weighted_sampler_t use samplers_base_mod implicit none private !> Constructor interface weighted_sampler module procedure weighted_sampler_new end interface weighted_sampler !> Derived type, extending from the base type , extends ( sampler_base_t ) :: weighted_sampler_t type ( rejection_maxheap_t ), allocatable :: samplers (:) integer ( i4 ) :: q = 0 ! number of groups type ( btree_t ) :: btree ! btree for the samplers selection (size q) integer ( i4 ), allocatable :: sampler_of_index (:) ! maps index to sampler real ( dp ) :: wmin , wmax contains procedure :: init_n => sampler_init procedure :: init_w => sampler_init_w procedure :: init_w2 => sampler_init_w2 procedure :: reset => sampler_reset procedure :: set_weight => sampler_set_weight procedure :: set_weight_array => sampler_set_weight_array procedure :: add_weight => sampler_add_weight procedure :: sample => sampler_sample procedure :: remove => sampler_remove procedure :: sum => sampler_sum procedure :: sampler_pos => sampler_sampler_pos final :: sampler_finalize end type public :: weighted_sampler , weighted_sampler_t contains !> Create a new sampler with N weights !> Input: n - number of weights function weighted_sampler_new ( n ) result ( this ) type ( weighted_sampler_t ) :: this integer ( i4 ), intent ( in ) :: n call this % init ( n ) end function weighted_sampler_new !> Initializes the structure with N weights !> Input: n - number of weights subroutine sampler_init ( this , n ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n integer ( i4 ) :: i this % n = n ! Set the number of weights ! DEBUG if ( this % q == 0 ) then error stop 'Error: q must be set before initializing the sampler.' end if allocate ( this % samplers ( this % q )) call this % btree % init ( this % q ) ! Initialize the btree for sampler selection ! init each sampler with size n do i = 1 , this % q call this % samplers ( i )% init ( n ) ! Initialize each sampler with n weights end do allocate ( this % sampler_of_index ( n )) allocate ( this % weights ( n )) this % sampler_of_index = 0 ! Initialize to zero (no sampler assigned yet) this % weights = 0.0_dp ! Initialize weights to zero end subroutine sampler_init !> Placeholder for 1D initialization (compat mode), maps to original init !> Input: n - number of weights !>        w - any real number, not used subroutine sampler_init_w ( this , n , w ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w call this % init ( n ) ! call original init end subroutine sampler_init_w !> Initializes the sampler giving its minimum and maximum weights !> This calculates the number of rejection samplers to use !> Input: n - number of weights !>        w1 - minimum weight !>        w2 - maximum weight subroutine sampler_init_w2 ( this , n , w1 , w2 ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w1 , w2 ! omega min and max ! calculate the number q (see https://arxiv.org/pdf/1808.05859) ! ensure that w1 is larger than zero if ( w1 <= 0.0_dp ) then error stop 'Error: min weight must be larger than zero.' end if this % wmin = w1 ! Set the minimum weight this % wmax = w2 ! Set the maximum weight this % q = max ( 1 , ceiling ( log ( this % wmax / this % wmin ) / log ( 2.0_dp ))) ! number of groups !write(*, fmt_general) 'Number of groups (q): ', this%q call this % init ( n ) ! call original init end subroutine sampler_init_w2 !> Resets the sampler: clears the list subroutine sampler_reset ( this ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( kind = i4 ) :: sampler_pos ! reset all samplers do sampler_pos = 1 , this % q call this % samplers ( sampler_pos )% reset () end do this % sampler_of_index = 0 ! Reset the index mapping this % weights = 0.0_dp ! Reset the weights call this % btree % reset () ! Reset the btree end subroutine sampler_reset !> Sets the weight for a given index !> Input: index - index of the element with a given weight !>        weight - weight of the element subroutine sampler_set_weight ( this , index , weight ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: weight integer ( i4 ) :: sampler_pos ! first we remove the weight, just to be sure call this % remove ( index ) ! Remove the index from the sampler if it exists if ( weight <= 0.0_dp ) then return end if sampler_pos = this % sampler_pos ( weight ) ! Get the sampler position based on the weight call this % samplers ( sampler_pos )% set_weight ( index , weight ) ! Set the weight in the first sampler this % sampler_of_index ( index ) = sampler_pos ! Map index to the corresponding sampler ! add weight to the btree call this % btree % add_weight ( sampler_pos , weight ) ! update the weights array this % weights ( index ) = weight end subroutine sampler_set_weight !> Sets the weights from an array (full), using its indexes !> Weights should be larger than zero !> It assumes it was initialized before, and has the same size !> Input: weights - array with the weights subroutine sampler_set_weight_array ( this , weights ) class ( weighted_sampler_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: weights (:) integer ( i4 ) :: i call this % reset () ! Reset the sampler before setting weights ! loop over all elements and set the weights do i = 1 , size ( weights ) call this % set_weight ( i , weights ( i )) ! Set the weight for each index end do end subroutine sampler_set_weight_array !> Adds a weight to the sampler at a given index !> Input: index - index of the element !>        delta_weight - difference to add to its weight subroutine sampler_add_weight ( this , index , delta_weight ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: delta_weight real ( dp ) :: weight weight = this % weights ( index ) + delta_weight ! Calculate the new weight ! we first remove the element call this % remove ( index ) ! Remove the index from the sampler ! Now we can add the weight again call this % set_weight ( index , weight ) ! Set the new weight end subroutine sampler_add_weight !> Remove an index from the sampler !> Important: the index is the original one, not the index used internally by the sampler !> Input: index - index of the element to be removed subroutine sampler_remove ( this , index ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index integer ( i4 ) :: sampler_pos real ( dp ) :: weight sampler_pos = this % sampler_of_index ( index ) ! Get the sampler position for the index if ( sampler_pos == 0 ) return ! It is not mapped to any sampler, just ignore call this % samplers ( sampler_pos )% remove ( index ) ! Remove weight in the first sampler this % sampler_of_index ( index ) = 0 ! Unmap index from first sampler weight = this % weights ( index ) ! Get the weight for the index ! update the weights array this % weights ( index ) = 0.0_dp ! Set the weight to zero ! remove weight from the btree call this % btree % add_weight ( sampler_pos , - weight ) end subroutine sampler_remove !> Samples an index from the sampler !> Input: gen - random number generator (rndgen-fortran module) !> Output: index - sampled index function sampler_sample ( this , gen ) result ( index ) use rndgen_mod class ( weighted_sampler_t ), intent ( in ) :: this class ( rndgen ), intent ( inout ) :: gen integer ( i4 ) :: index integer ( i4 ) :: sampler_pos sampler_pos = this % btree % sample ( gen ) ! Get a sampler position from the btree ! samples from the corresponding rejection sampler index = this % samplers ( sampler_pos )% sample ( gen ) end function !> Get the sum of all weights !> Output: total - sum of all weights function sampler_sum ( this ) result ( total_weight ) class ( weighted_sampler_t ), intent ( in ) :: this real ( dp ) :: total_weight total_weight = this % btree % sum () end function sampler_sum !> Finalize the sampler, deallocate resources subroutine sampler_finalize ( this ) type ( weighted_sampler_t ), intent ( inout ) :: this if ( allocated ( this % sampler_of_index )) then deallocate ( this % sampler_of_index ) end if if ( allocated ( this % weights )) then deallocate ( this % weights ) end if end subroutine sampler_finalize !> Auxiliary function (private) to get the sampler position for a given weight !> Input: weight - the weight to find the sampler position for function sampler_sampler_pos ( this , weight ) result ( pos ) class ( weighted_sampler_t ), intent ( in ) :: this real ( dp ), intent ( in ) :: weight integer ( i4 ) :: pos if ( weight < this % wmin ) then pos = 1 else ! Calculate the sampler position based on the weight pos = min ( this % q , ceiling ( log ( weight / this % wmin ) / log ( 2.0_dp )) + 1 ) end if end function sampler_sampler_pos end module samplers_rejection_maxheap_composition_mod","tags":"","url":"sourcefile/rejection_maxheap_composition.f90.html"},{"title":"rejection_two_classes.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~rejection_two_classes.f90~~EfferentGraph sourcefile~rejection_two_classes.f90 rejection_two_classes.f90 sourcefile~base.f90 base.f90 sourcefile~rejection_two_classes.f90->sourcefile~base.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~rejection_two_classes.f90->sourcefile~kinds.f90 sourcefile~lists.f90 lists.f90 sourcefile~rejection_two_classes.f90->sourcefile~lists.f90 sourcefile~rejection.f90 rejection.f90 sourcefile~rejection_two_classes.f90->sourcefile~rejection.f90 sourcefile~base.f90->sourcefile~kinds.f90 sourcefile~lists.f90->sourcefile~kinds.f90 sourcefile~dynamical_list.f90 dynamical_list.f90 sourcefile~lists.f90->sourcefile~dynamical_list.f90 sourcefile~fixed_list.f90 fixed_list.f90 sourcefile~lists.f90->sourcefile~fixed_list.f90 sourcefile~maxheap.f90 maxheap.f90 sourcefile~lists.f90->sourcefile~maxheap.f90 sourcefile~rejection.f90->sourcefile~base.f90 sourcefile~rejection.f90->sourcefile~kinds.f90 sourcefile~rejection.f90->sourcefile~lists.f90 sourcefile~dynamical_list.f90->sourcefile~kinds.f90 sourcefile~fixed_list.f90->sourcefile~kinds.f90 sourcefile~maxheap.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~rejection_two_classes.f90~~AfferentGraph sourcefile~rejection_two_classes.f90 rejection_two_classes.f90 sourcefile~samplers.f90 samplers.f90 sourcefile~samplers.f90->sourcefile~rejection_two_classes.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> This module implements rejection sampling with two classes !> We split the weights into two classes based on a threshold module samplers_rejection_two_classes_mod use kinds_mod use lists_mod use samplers_rejection_mod , only : rejection_t => weighted_sampler_t use samplers_base_mod implicit none private !> Constructor interface weighted_sampler module procedure weighted_sampler_new end interface weighted_sampler !> Derived type, extending from the base type , extends ( sampler_base_t ) :: weighted_sampler_t type ( rejection_t ) :: samplers ( 2 ) real ( dp ) :: threshold = huge ( dp ) ! threshold for the weights integer ( i4 ), allocatable :: sampler_of_index (:) ! maps index to sampler (1 or 2) contains procedure :: init_n => sampler_init procedure :: init_w => sampler_init_w procedure :: init_w2 => sampler_init_w2 procedure :: reset => sampler_reset procedure :: set_weight => sampler_set_weight procedure :: set_weight_array => sampler_set_weight_array procedure :: add_weight => sampler_add_weight procedure :: sample => sampler_sample procedure :: remove => sampler_remove procedure :: sum => sampler_sum final :: sampler_finalize end type public :: weighted_sampler , weighted_sampler_t contains !> Create a new rejection sampler with N weights !> Input: n - number of weights function weighted_sampler_new ( n ) result ( this ) type ( weighted_sampler_t ) :: this integer ( i4 ), intent ( in ) :: n call this % init ( n ) end function weighted_sampler_new !> Initializes the structure with N weights !> Input: n - number of weights subroutine sampler_init ( this , n ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n this % n = n ! Set the number of weights ! init each sampler with size n call this % samplers ( 1 )% init ( n ) call this % samplers ( 2 )% init ( n ) allocate ( this % sampler_of_index ( n )) allocate ( this % weights ( n )) this % sampler_of_index = 0 ! Initialize to zero (no sampler assigned yet) this % weights = 0.0_dp ! Initialize weights to zero end subroutine sampler_init !> Initializes with size n and threshold w !> Input: n - number of weights !>        w - threshold for the weights subroutine sampler_init_w ( this , n , w ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w call this % init ( n ) ! call original init this % threshold = w ! set the threshold for the weights end subroutine sampler_init_w !> Placeholder for 1D initialization (compat mode), maps to original init !> Input: n - number of weights !>        w1 - any real number, not used !>        w2 - any real number, not used subroutine sampler_init_w2 ( this , n , w1 , w2 ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w1 , w2 call this % init ( n , w1 ) ! call original init end subroutine sampler_init_w2 !> Resets the sampler: clears the list subroutine sampler_reset ( this ) class ( weighted_sampler_t ), intent ( inout ) :: this call this % samplers ( 1 )% reset () ! Reset the first sampler call this % samplers ( 2 )% reset () ! Reset the second sampler this % sampler_of_index = 0 ! Reset the index mapping this % weights = 0.0_dp ! Reset the weights end subroutine sampler_reset !> Sets the weight for a given index !> Input: index - index of the element with a given weight !>        weight - weight of the element subroutine sampler_set_weight ( this , index , weight ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: weight integer ( i4 ) :: old_sampler_pos ! get the sampler pos old_sampler_pos = this % sampler_of_index ( index ) ! We select which sampler will receive the weight based on the threshold ! The first sampler will receive weights below the threshold ! The second sampler will receive weights above the threshold if ( weight < this % threshold ) then call this % samplers ( 1 )% set_weight ( index , weight ) ! Set the weight in the first sampler this % sampler_of_index ( index ) = 1 ! Map index to first sampler ! If it was in the second sampler, we need to remove it if ( old_sampler_pos == 2 ) call this % samplers ( 2 )% remove ( index ) else call this % samplers ( 2 )% set_weight ( index , weight ) ! Set the weight in the second sampler this % sampler_of_index ( index ) = 2 ! Map index to second sampler ! If it was in the first sampler, we need to remove it if ( old_sampler_pos == 1 ) call this % samplers ( 1 )% remove ( index ) end if ! update the weights array this % weights ( index ) = weight end subroutine sampler_set_weight !> Sets the weights from an array (full), using its indexes !> Weights should be larger than zero !> It assumes it was initialized before, and has the same size !> Input: weights - array with the weights subroutine sampler_set_weight_array ( this , weights ) class ( weighted_sampler_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: weights (:) integer ( i4 ) :: i ! We select which sampler will receive the weights based on the threshold ! The first sampler will receive weights below the threshold ! The second sampler will receive weights above the threshold do i = 1 , size ( weights ) call this % set_weight ( i , weights ( i )) end do end subroutine sampler_set_weight_array !> Adds a weight to the sampler at a given index !> Input: index - index of the element !>        delta_weight - difference to add to its weight subroutine sampler_add_weight ( this , index , delta_weight ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: delta_weight real ( dp ) :: weight weight = this % weights ( index ) + delta_weight ! Calculate the new weight ! we first remove the element call this % remove ( index ) ! Remove the index from the sampler ! Now we can add the weight again call this % set_weight ( index , weight ) ! Set the new weight end subroutine sampler_add_weight !> Remove an index from the sampler !> Important: the index is the original one, not the index used internally by the sampler !> Input: index - index of the element to be removed subroutine sampler_remove ( this , index ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index integer ( i4 ) :: sampler_pos sampler_pos = this % sampler_of_index ( index ) ! Get the sampler position for the index if ( sampler_pos == 0 ) return ! It is not mapped to any sampler, just ignore call this % samplers ( sampler_pos )% remove ( index ) ! Remove weight in the first sampler this % sampler_of_index ( index ) = 0 ! Unmap index ! update the weights array this % weights ( index ) = 0.0_dp ! Set the weight to zero end subroutine sampler_remove !> Samples an index from the sampler !> Input: gen - random number generator (rndgen-fortran module) !> Output: index - sampled index function sampler_sample ( this , gen ) result ( index ) use rndgen_mod class ( weighted_sampler_t ), intent ( in ) :: this class ( rndgen ), intent ( inout ) :: gen integer ( i4 ) :: index real ( dp ) :: total_weight total_weight = this % sum () ! We will use rejection sampling to select an index ! First, we see which sampler to use based on the total weight if ( gen % rnd () < this % samplers ( 1 )% sum () / total_weight ) then ! Use the first sampler index = this % samplers ( 1 )% sample ( gen ) else ! Use the second sampler index = this % samplers ( 2 )% sample ( gen ) end if end function !> Get the sum of all weights !> Output: total - sum of all weights function sampler_sum ( this ) result ( total_weight ) class ( weighted_sampler_t ), intent ( in ) :: this real ( dp ) :: total_weight total_weight = this % samplers ( 1 )% sum () + this % samplers ( 2 )% sum () end function sampler_sum !> Finalize the sampler, deallocate resources subroutine sampler_finalize ( this ) type ( weighted_sampler_t ), intent ( inout ) :: this if ( allocated ( this % sampler_of_index )) then deallocate ( this % sampler_of_index ) end if if ( allocated ( this % weights )) then deallocate ( this % weights ) end if end subroutine sampler_finalize end module samplers_rejection_two_classes_mod","tags":"","url":"sourcefile/rejection_two_classes.f90.html"},{"title":"rejection.f90 – Data structures for Fortran","text":"This file depends on sourcefile~~rejection.f90~~EfferentGraph sourcefile~rejection.f90 rejection.f90 sourcefile~base.f90 base.f90 sourcefile~rejection.f90->sourcefile~base.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~rejection.f90->sourcefile~kinds.f90 sourcefile~lists.f90 lists.f90 sourcefile~rejection.f90->sourcefile~lists.f90 sourcefile~base.f90->sourcefile~kinds.f90 sourcefile~lists.f90->sourcefile~kinds.f90 sourcefile~dynamical_list.f90 dynamical_list.f90 sourcefile~lists.f90->sourcefile~dynamical_list.f90 sourcefile~fixed_list.f90 fixed_list.f90 sourcefile~lists.f90->sourcefile~fixed_list.f90 sourcefile~maxheap.f90 maxheap.f90 sourcefile~lists.f90->sourcefile~maxheap.f90 sourcefile~dynamical_list.f90->sourcefile~kinds.f90 sourcefile~fixed_list.f90->sourcefile~kinds.f90 sourcefile~maxheap.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~rejection.f90~~AfferentGraph sourcefile~rejection.f90 rejection.f90 sourcefile~rejection_two_classes.f90 rejection_two_classes.f90 sourcefile~rejection_two_classes.f90->sourcefile~rejection.f90 sourcefile~samplers.f90 samplers.f90 sourcefile~samplers.f90->sourcefile~rejection.f90 sourcefile~samplers.f90->sourcefile~rejection_two_classes.f90 sourcefile~datastructs-fortran.f90 datastructs-fortran.f90 sourcefile~datastructs-fortran.f90->sourcefile~samplers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> This module implements a rejection sampling module samplers_rejection_mod use kinds_mod use lists_mod use samplers_base_mod implicit none private real ( kind = dp ), parameter :: EPSILON = 0.0_dp !> Constructor interface weighted_sampler module procedure weighted_sampler_new end interface weighted_sampler !> Derived type, extending from the base type , extends ( sampler_base_t ) :: weighted_sampler_t type ( dynamical_list_t ), allocatable :: indices integer ( i4 ), allocatable :: position_of (:) ! index positions real ( kind = dp ) :: current_sum = 0.0_dp ! current sum of the weights real ( kind = dp ) :: max_weight = 0.0_dp contains procedure :: init_n => sampler_init procedure :: init_w => sampler_init_w procedure :: init_w2 => sampler_init_w2 procedure :: reset => sampler_reset procedure :: set_weight => sampler_set_weight procedure :: set_weight_array => sampler_set_weight_array procedure :: add_weight => sampler_add_weight procedure :: sample => sampler_sample procedure :: remove => sampler_remove procedure :: sum => sampler_sum final :: sampler_finalize end type weighted_sampler_t public :: weighted_sampler , weighted_sampler_t contains !> Create a new rejection sampler with N weights !> Input: n - number of weights function weighted_sampler_new ( n ) result ( this ) type ( weighted_sampler_t ) :: this integer ( i4 ), intent ( in ) :: n call this % init ( n ) end function weighted_sampler_new !> Initializes the structure with N weights !> Input: n - number of weights subroutine sampler_init ( this , n ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n this % n = n allocate ( this % weights ( n )) allocate ( this % indices ) allocate ( this % position_of ( n )) call this % indices % init ( n ) this % position_of = 0 this % current_sum = 0.0_dp this % max_weight = 0.0_dp this % weights = 0.0_dp ! Initialize weights to zero end subroutine sampler_init !> Placeholder for 1D initialization (compat mode), maps to original init !> Input: n - number of weights !>        w - any real number, not used subroutine sampler_init_w ( this , n , w ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w call this % init ( n ) ! call original init end subroutine sampler_init_w !> Placeholder for 1D initialization (compat mode), maps to original init !> Input: n - number of weights !>        w1 - any real number, not used !>        w2 - any real number, not used subroutine sampler_init_w2 ( this , n , w1 , w2 ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: n real ( dp ), intent ( in ) :: w1 , w2 call this % init ( n ) ! call original init end subroutine sampler_init_w2 !> Resets the sampler: clears the list subroutine sampler_reset ( this ) class ( weighted_sampler_t ), intent ( inout ) :: this call this % indices % reset () this % position_of = 0 this % current_sum = 0.0_dp this % max_weight = 0.0_dp this % weights = 0.0_dp end subroutine sampler_reset !> Sets the weight for a given index !> Input: index - index of the element with a given weight !>        weight - weight of the element subroutine sampler_set_weight ( this , index , weight ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: weight ! DEBUG !if (index < 1 .or. index > this%n) error stop 'Index out of bounds in sampler_set_weight' ! if the weight is zero, remove the index from the list if ( weight <= EPSILON ) then call this % remove ( index ) return end if ! check if the index is already added to the list if ( this % position_of ( index ) /= 0 ) then ! remove the current sum this % current_sum = this % current_sum - this % weights ( index ) else call this % indices % add ( index ) this % position_of ( index ) = this % indices % n_used end if ! sets the weight this % weights ( index ) = weight ! update the current sum this % current_sum = this % current_sum + weight ! we do not remove the last weight since it is a new one ! update the maximum weight if ( weight > this % max_weight ) this % max_weight = weight end subroutine sampler_set_weight !> Sets the weights from an array (full), using its indexes !> Weights should be larger than zero !> It assumes it was initialized before, and has the same size !> Input: weights - array with the weights subroutine sampler_set_weight_array ( this , weights ) class ( weighted_sampler_t ), intent ( inout ) :: this real ( dp ), intent ( in ) :: weights (:) integer ( i4 ) :: i ! DEBUG !if (size(weights) /= this%n) error stop 'Weights array size does not match sampler size' this % weights = weights call this % indices % reset () ! Reset the indices list this % current_sum = 0.0_dp do i = 1 , this % n call this % indices % add ( i ) this % position_of ( i ) = this % indices % n_used this % current_sum = this % current_sum + weights ( i ) end do ! update the maximum weight this % max_weight = maxval ( weights ) end subroutine sampler_set_weight_array !> Adds a weight to the sampler at a given index !> Input: index - index of the element !>        delta_weight - difference to add to its weight subroutine sampler_add_weight ( this , index , delta_weight ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index real ( dp ), intent ( in ) :: delta_weight ! DEBUG !if (index < 1 .or. index > this%n) error stop 'Index out of bounds in sampler_add_weight' call this % set_weight ( index , this % weights ( index ) + delta_weight ) end subroutine sampler_add_weight !> Remove an index from the sampler !> Important: the index is the original one, not the index used internally by the sampler !> Input: index - index of the element to be removed subroutine sampler_remove ( this , index ) class ( weighted_sampler_t ), intent ( inout ) :: this integer ( i4 ), intent ( in ) :: index integer ( i4 ) :: pos ! DEBUG !if (index < 1 .or. index > this%n) error stop 'Index out of bounds in sampler_remove' pos = this % position_of ( index ) if ( pos /= 0 ) then ! Update the current sum this % current_sum = this % current_sum - this % weights ( index ) ! Update the position_of the last element of the list this % position_of ( this % indices % list ( this % indices % n_used )) = pos ! Remove the weight from the list call this % indices % remove ( pos ) this % position_of ( index ) = 0 ! Mark as removed this % weights ( index ) = 0.0_dp ! Set the weight to zero end if end subroutine sampler_remove !> Samples an index from the sampler !> Input: gen - random number generator (rndgen-fortran module) !> Output: index - sampled index function sampler_sample ( this , gen ) result ( index ) use rndgen_mod class ( weighted_sampler_t ), intent ( in ) :: this class ( rndgen ), intent ( inout ) :: gen integer ( i4 ) :: index , index_pos real ( dp ) :: weight ! We will use rejection sampling to select an index do ! Select a random index from the list of indices index_pos = gen % int ( 1 , this % indices % n_used ) index = this % indices % list ( index_pos ) weight = this % weights ( index ) ! Check if the rate is sufficient to accept this index if ( gen % rnd () < weight / this % max_weight ) return ! else, we reject and try again end do end function !> Get the sum of all weights !> Output: total - sum of all weights function sampler_sum ( this ) result ( total_weight ) class ( weighted_sampler_t ), intent ( in ) :: this real ( dp ) :: total_weight total_weight = this % current_sum end function sampler_sum !> Finalize the sampler, deallocate resources subroutine sampler_finalize ( this ) type ( weighted_sampler_t ), intent ( inout ) :: this if ( allocated ( this % indices )) then deallocate ( this % indices ) end if if ( allocated ( this % weights )) then deallocate ( this % weights ) end if if ( allocated ( this % position_of )) then deallocate ( this % position_of ) end if end subroutine sampler_finalize end module samplers_rejection_mod","tags":"","url":"sourcefile/rejection.f90.html"}]}